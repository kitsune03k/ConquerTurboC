 임인건   (turbo28 )
[강좌] C포인터4: 포인터 배열

작성 연월일: 1989.10.28
마이크로소프트웨어 게재: 1989.12
HWP/TXT 변환: 1993.3.5

                         >>> 정복 터보 C <<<

      제4회  매개변수가 다차원 배열인 함수와 포인터 배열의 정복

                   글/임인건 (서울대 기계공학과3)


---------------------------------------------------------------------
  1  본론에 앞서
---------------------------------------------------------------------

    이제 이 정복 터보 C 연재도 막바지에 다다랐다. 우선은 지난 달에 마
저 설명하지 못한 "매개변수가 다차원 배열인 함수"를 만드는 방법부터 설
명할 작정이다. 여기에 관심이 없는 독자는 그 다음 큰 제목인 "포인터 배
열"부터 읽어 나가기 바란다.
    포인터 배열(pointer array)은, 모르는 사람에게는 지극히 생소한  용
어일 테지만, C에서 대단히 빈번하게 쓰이는 데이터형이다. 왜냐하면  C에
서는 포인터 배열로 문자열 배열을 구현하기 때문이다. 그래서 포인터  배
열을 모르고서는 C에서 문자열 배열을 쓸 수는 없다고 보면 틀림없다.
    이번 달에는 특히 C로 문자열들의 (다차원) 배열을  처리하고자  하는
독자에게 유익하리라 믿는다. 그 동안 포인터 배열의 정의, 초기화,  참조
방법에 있어서 오는 여러 가지 혼동으로 말미암아 적잖이  고생한  독자는
이번 기회에 포인터 배열과 그 제반 사항을 학실하게 정복하기 바란다. 또
한 지금까지 문자열 배열을 이차원 문자 배열로 구현해 왔던 독자는  이번
글을 유심히 읽어볼 필요가 있다. 아마 메모리 낭비의 진수를  깨닫게  될
것이다.
    이제 본문으로 들어갈텐데, 아마 사흘 정도면 이 글을 정복할 수 있을
것으로 본다. 그리고 이 글에서 소개하는 예제는 눈으로 훑어보지 말고 반
드시 실제로 터보 C 상에서 입력하여 실행시켜 보는 것이 여러 가지로  바
람직하다. 말인 즉 복잡한 수학 문제를 암산으로 해결하려는 만용은  빨리
버릴수록 좋다는 뜻이다.


---------------------------------------------------------------------
  2  매개변수가 다차원 배열인 함수
---------------------------------------------------------------------

    지난 11월 연재에 이어 매개변수가 다차원 배열인 함수를 만드는 방법
을 간략하게 언급한 다음, 문자열 배열을 구현하는 데 필수불가결한  포인
터 배열에 대하여 계속해서 설명해 나가겠다.
    우선, 매개변수가 다차원 배열인 함수를 만드는 방법은 일차원 배열의
경우만큼이나 간단하다. 지난 11월 연재에서 실컷 설명한 다차원 배열  포
인터를 사용하면 된다.
    <예제 1>의 bubblesort와 printdays 함수가 그 실례이다. 여기서 swap
str은 매개변수가 일차원 배열인 함수이다. 11월 연재를 충분히  이해했다
면 아마 <예제 1>쯤은 쉽게 분석할 수 있으리라 생각된다. <예제 1>는  길
이(열의 갯수)가 3으로 고정되어 있는 7개(행의 갯수)의 요일명을  알파벳
순으로 정렬하는 프로그램인데, 정렬하는 알고리즘으로는 거품 정렬(bubbl
e sort)을 택했다. 원래 문자열 배열을 정렬하려면 색인 배열(index  arra
y)을 따로 마련하여 택 정렬(tag sort)을 하는 것이 가장 효율적이지만 여
기서는 예제인 만큼 그런 방식을 택하지 않았다.

<예제 1> 거품 정렬 알고리즘에 의한 이차원 문자 배열의 정렬
---------------------------------------------------------------------
#define ROW 7 -+- 매크로 상수의 정의
#define COL 3 -+
                       +---- 이차원 배열 포인터
void printdays(char (*days)[COL], unsigned row);  -+
void bubblesort(char days[][COL], unsigned row);   +- 함수 선언
void swapstr(char s1[], char s2[], unsigned col); -+

void main(void)
{
    char days[ROW][COL] = {
        {'S', 'U', 'N'},-+
        {'M', 'O', 'N'}, |
        {'T', 'U', 'E'}, |
        {'W', 'E', 'D'}, +- 이차원 문자 배열을 더 간단하게 초기화하는
        {'T', 'H', 'R'}, |  방법이 있지만 좀 있다가 언급하겠다.
        {'F', 'R', 'I'}, |
        {'S', 'A', 'T'},-+
    };

    bubblesort(days, ROW);

    printdays(days, ROW);
}

void printdays(char (*days)[COL], unsigned row)
{                       |
    int i, j;           +----------------+
                                         | 매개변수 리스트 내에서
    for (i = 0; i < row; i++) {          | 두 선언은 완전히
        for (j = 0; j < COL; j++)        | 동일하다.
            printf("%c", days[i][j]);    |
        printf("\n");                    |
    }                                    |
}                      +-----------------+
                       |
void bubblesort(char days[][COL], unsigned row)
{
    register i, j;
                                   부분배열의 크기(열의 갯수)
    for (i = 0; i < row - 1; i++)          |
        for (j = row - 1; j > i; j--)      |
            swapstr(days[j - 1], days[j], COL);
}                     |           |
                      +-----------+----- 부분배열명
void swapstr(char s1[], char s2[], unsigned col)
{
    register i, temp;

    for (i = 0; i < col; i++) { <--- 요일명을 비교한다.
        if (s1[i] > s2[i]) break;
        else if (s1[i] < s2[i]) return; <--- s1이 s2보다
    }                                        앞이면 리턴한다.

    if (i == col) return;      <--- 두 요일명이 완전히
                                    동일하면 리턴한다.
    for (i = 0; i < col; i++) { <--- 요일명을 교환한다.
        temp = s1[i];
        s1[i] = s2[i];
        s2[i] = temp;
    }
}
---------------------------------------------------------------------
실행 결과

FRI
MON
SAT
SUN
THR
TUE
WED
---------------------------------------------------------------------

    <예제 1>의 printdays와 bubblesort 함수를 보아도 알 수 있겠지만 함
수의 매개변수 리스트에서는 char (*days)[COL]과 char days[][COL] 등  2
가지 선언이 완전히 동일(identical)하다.
    일반적으로 함수의 매개변수 리스트에서 아래의 두 선언은 완전히  동
일하다. 함수의 매개변수 리스트 내에서만 그렇다는 사실에 주의하기 바란
다. 이때 각 첨자크기는 물론 상수 수식이어야 한다.

    +----------------------------------------+
    | T arrayp[][size2][size3]......[sizen]  |
    |                                        |
    | T (*arrayp)[size2][size3]......[sizen] |
    +----------------------------------------+
 

---------------------------------------------------------------------
  3  포인터 배열
---------------------------------------------------------------------

  3.1 포인터 배열이란?

    포인터 배열(pointer array)이란 말 그대로 포인터 변수가 배열요소인
배열을 뜻한다. 포인터 배열이 필요한 이유는 아래와 같다.

+-------------------------------------------------------------------+
| 포인터 배열로 길이가 일정치 않은 문자열들의 배열을 구현할 수 있다 |
+-------------------------------------------------------------------+

    말인 즉 포인터 배열로 문자열 상수들의 배열을 구현하자는 것이다. C
에는 문자열 배열이란 것이 원칙적으로 존재하지 않는다는 것쯤은 익히 들
어서 알고 있을 줄로 믿는다. 따라서 C에서는 이차원 문자 배열 또는 포인
터 배열을 써서 문자열 배열을 구현해야만 하는데, 여기서는 그  두  가지
방법을 비교해 봄으로써, 포인터 배열로 문자열 배열을  구현하는  방법이
월등하게 효율적인 까닭을 설명하겠다.

  3.2 이차원 문자 배열에 의한 문자열 배열의 구현과 그 문제점

    문자열 배열을 구현하기 위해서 이차원 문자 배열을 쓸  때와  포인터
배열을 쓸 때의 차이점을 명확히 대비시키기 위하여 <예제 2>과 <예제  3>
를 마련했다. 두 예제 모두 9개의 문자열, 즉 메뉴를 배열화하여 for 순환
문으로 화면에 출력하도록 하는 것이다. 그런데 문자열을 배열화하는 방법
에 있어서 <예제 2>와 <예제 3>은 서로 전혀 다른 방법을 취하고 있다. 과
연 메모리의 절약과 실행 시간의 절약이라는 측면에서, 어느 방법이 더 효
율적인가를 주의깊게 살펴보기 바란다.

<예제 2>  이차원 문자 배열에 의한 메뉴의 출력
---------------------------------------------------------------------
#define MAXMENU 9    <--- 메뉴의 갯수
#define MAXLENGTH 15 <--- 메뉴 항목의 최대 길이

void main(void)
{
    char s[MAXMENU + 1][MAXLENGTH + 1]; <--- 이차원 문자 배열의 정의
    int i, sum;      |              +----- 널 종료문자를 위한 여분
                     +------------------ 편의상 s[0]는 쓰지 않는다.
    strcpy(s[1], " [1] Load");      --+
    strcpy(s[2], " [2] Pick");        | 문자열 상수를
    strcpy(s[3], " [3] New");         | s의 각 부분배열에
    strcpy(s[4], " [4] Save");        | 일일이 복사한다.
    strcpy(s[5], " [5] Write to");    | 이 문자열 상수들도
    strcpy(s[6], " [6] Directory");   | 메모리의 어딘가에
    strcpy(s[7], " [7] Change dir");  | 자리를 차지하고 있다.
    strcpy(s[8], " [8] OS shell");    | (총 108 바이트)
    strcpy(s[9], " [9] Quit");      --+

    for (i = 1; i <= MAXMENU; i++) -+ 메뉴를 출력한다.
        printf("%s\n", s[i]);      -+

    printf("\nSize of array s: %d bytes.\n\n", sizeof(s));
                    이차원 문자 배열에 할당된 ----+
                    메모리 크기를 구한다.
    for (sum = 0, i = 1; i <= MAXMENU; i++)
        sum += strlen(s[i]) + 1;

    printf("Total real length of all strings: %d bytes.\n\n", sum);

    printf("Total memory allocated: %d + %d = %d bytes.\n",
           sizeof(s), sum, sum + sizeof(s));
}
---------------------------------------------------------------------
실행결과

 [1] Load
 [2] Pick
 [3] New                +-배열로 잡은 160 바이트와 메모리의
 [4] Save               | 어딘가에 문자열 상수로 저장되어 있는
 [5] Write to           | 108 바이트를 합하면 결국 268 바이트가 된다.
 [6] Directory    +-----+ 실제 문자열 상수들의 총 바이트 크기(108)와
 [7] Change dir   |     | 비교해 볼 때, 메모리 사용에 상당한 낭비가
 [8] OS shell     |     +-있음을 알 수 있다.
 [9] Quit         |
                  |
Size of array s: 160 bytes.

Total real length of all strings: 108 bytes.

Total memory allocated: 160 + 108 = 268 bytes.
---------------------------------------------------------------------

    <예제 2>는 문자열의 배열을 이차원 문자 배열로 구현하고 있다. 또한
이차원 배열 s의 각 부분배열에 strcpy 함수를 호출하여 문자열을  저장하
고 있다. 그런데 이 방법에는 다소 비효율적인 구석이 있다. 왜냐하면 s에
그냥 남아도는 공간이 많이 생기기 때문이다.
    메뉴의 항목 중에서 " [7] Change dir"가 15자로 제일 길기 때문에 각
부분배열의 크기는, 널 종료문자(null terminator) '\0'을 위한 한 바이트
를 포함하여 총 16바이트로 일정하도록 MAXLENGTH + 1로 잡았다. 따라서 s
의 부분배열은 모두 크기가 16으로 일정한 1차원 문자 배열들이다. 그레서
배열 s는 16 * 10(부분배열의 갯수) == 160 바이트의 메모리를 차지한다.
    크기가 일정치 않은 문자열들의 실제 크기의 합은 널 종료문자까지 포
함하여 108 바이트 밖에 안 되는데도, 이것을 160 바이트의  일정한  틀에
우겨 넣으려니 당연히 남는 공간이 생기는 것이다. 여기서 파생되는  문제
점이란 바로 길이가 들쑥날쑥 일정치 않은 문자열들을 크기가 일정한 문자
배열 안에 집어 넣으려는데 있다.

[그림 1]  배열 s의 배열요소들이 남아돈다
---------------------------------------------------------------------

 strspy 함수에 의한
 실제로 복사된 부분          그냥 남아도는 배열요소 12바이트
   +------------+  +---------------------------------------------+
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  | N | e | w | \0|   |   |   |   |   |   |   |   |   |   |   |   |
  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
   [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10][11][12][13][14][15]

---------------------------------------------------------------------

    부분배열 s[7]의 경우에는 문자열의 길이와 배열크기가 정확히 딱  들
어 맞는다. 그러나 다른 부분배열들은 전혀 그렇지가 못하다.  예를  들어
저장된 문자열의 길이가 개중에 가장 짧은 s[3] 부분배열의 경우 [그림 1]
을 보아도 알 수 있듯이 배열요소가 12바이트씩이나 남아돈다. 즉  자그마
치 자신의 75%나 되는 공간을 낭비하고 있다는 계산이 나온다.
    이것은 상당히 비효율적인 메모리 관리 방식이 아닐 수 없다.  게다가
strcpy 함수를 호출하여 메뉴 문자열을 s의 부분배열에 복사하는 과정에서
도 실행 시간이 무시 못할 정도로 잡아 먹힌다. 만약에 메뉴의 갯수가  수
십 개 정도 된다고 하면 그 소요되는 시간도 당연히 고려 대상에 포함시켜
야 한다.
    하여간에 <예제 2>는 여러모로 헛점 투성이의 프로그램이다. 사실 <예
제 2>와 같은 문자열 처리 방식은 임의 접근(random access)이 필요할  때
이외에는 그 메모리 낭비가 워낙 심하기 때문에 C에서 별로  쓰이지  않는
다. <예제 2>는 그러니까 파스칼에서나 쓰였던 방식이라고 할 수 있다. 파
스칼에서는 := 연산자가 C의 strcpy 함수의 역할을 담당한다는 사실을  상
기하기 바란다.

  3.3 포인터 배열에 의한 문자열 배열의 구현

    앞의 메모리 낭비형 <예제 2>보다 한결 나은 방법이 아래에서  제시하
는 <예제 3>이다. 즉 포인터 배열로 문자열의 배열을 구현하는  방법이다.
여기서 한 가지 주의할 사항은, 좀 전에도 말했듯이 애초부터 C에는  문자
열 배열이란 것이 전혀 존재하지 않는다는 점이다. 다만 포인터 배열을 활
용하여 문자열의 배열을 구현할 뿐임을 분명히 짚고 넘어가야 한다.  여기
에 대하여 괜한 착각이 없기를 바란다.

<예제 3>  포인터 배열에 의한 메뉴의 출력
---------------------------------------------------------------------
#define MAXMENU 9

void main(void)
{
    char *ps[MAXMENU + 1]; <--- 포인터 배열 ps의 정의
    int i, sum;

    ps[1] = " [1] Load";      -+
    ps[2] = " [2] Pick";       |
    ps[3] = " [3] New";        | 문자열 상수의 선두번지를
    ps[4] = " [4] Save";       | 포인터 배열의 각 배열요소에
    ps[5] = " [5] Write to";   | 대입한다. 즉 포인터 배열의 각 요소를
    ps[6] = " [6] Directory";  | 초기화한다.
    ps[7] = " [7] Change dir"; |
    ps[8] = " [8] OS shell";   |
    ps[9] = " [9] Quit";      -+

    for (i = 1; i <= MAXMENU; i++) -+- 메뉴를 출력한다.
        printf("%s\n", ps[i]);     -+

    printf("\nSize of pointer array ps: %d bytes.\n\n", sizeof(ps));
                                                         |
                                    포인터 배열 ps의 바이트 크기 계산
    for (sum = 0, i = 1; i <= MAXMENU; i++)
        sum += strlen(ps[i]) + 1;

    printf("Total real length of all strings: %d bytes.\n\n", sum);

    printf("Total memory allocated: %d + %d = %d bytes\n",
           sizeof(ps), sum, sizeof(ps)+ sum);
}
---------------------------------------------------------------------
실행 결과

 [1] Load
 [2] Pick
 [3] New
 [4] Save
 [5] Write to
 [6] Directory                     +- 메모리 할당에 거의 낭비가 없다.
 [7] Change dir            +-------+
 [8] OS shell              |       |               전체 할당된 메모리
 [9] Quit                  |       |                   |
                           |       |    (20 + 108) == 128 바이트
Size of pointer array ps: 20 bytes.|     |     +-문자열 상수들의 길이
                                   |     +--- 포인터 배열을 위한 공간
Total real length of all strings: 108 bytes.

Total memory allocated: 20 + 108 = 128 bytes.
---------------------------------------------------------------------

[그림 2]  포인터 배열이 초기화된 직후 상황의 개념도
---------------------------------------------------------------------

                                      길이가 일정치 않은
  포인터 배열 ps                      문자열 상수들
    +-------+                         +------------+
[0] |       |           +-------------| [1] Load\0 |
    +-------+           |             +------------+
[1] |   o --+-----------+             +------------+
    +-------+             +-----------| [2] Pick\0 |
[2] |   o --+-------------+           +------------+
    +-------+                         +-----------+
[3] |   o --+-------------------------| [3] New\0 |
    +-------+                         +-----------+
[4] |   o --+-------------+           +------------+
    +-------+             +-----------| [4] Save\0 |
[5] |   o --+-----------+             +------------+
    +-------+           |             +----------------+
[6] |   o --+---------+ +-------------| [5] Write to\0 |
    +-------+         |               +----------------+
[7] |   o --+-------+ |               +-----------------+
    +-------+       | +---------------| [6] Directory\0 |
[8] |   o --+-----+ |                 +-----------------+
    +-------+     | |                 +------------------+
[9] |   o --+---+ | +-----------------| [7] Change dir\0 |
 |  +-------+   | |                   +------------------+
 |              | |                   +----------------+
배열요소        | +-------------------| [8] OS shell\0 |
                |                     +----------------+
                |                     +------------+
                +---------------------| [9] quit\0 |
                대입 연산자 =에 의해  +------------+
                각각 초기화된다.

     ps[0]는 일반적으로 1부터 시작되는 메뉴 항목 번호와 배열의 첨자를
    자연스럽게 일치시키기 위하여 의도적으로 사용하지 않았다. 이  또한
    메모리 2 바이트를 잡아 먹지만 <예제 2>에서 16 바이트 크기의  부분
    배열 s[0]를 만들어 놓고도 쓰지 않는 것보다는 한참 낫다. 여기서 오
    히려 s[0]를 억지로 사용하면, 메뉴 항목 번호와 첨자가 서로  일치하
    지 않는 데서 오는 혼란으로 인해 결과적으로는 밑지는 장사가 된다.

---------------------------------------------------------------------

    <예제 3>는 [그림 2]를 참고하면 어렵지 않게 이해할 수 있으리라  생
각한다. 이제는 일반적으로 포인터 배열을 정의하는 방법에 대해서 알아보
자. 배열요소인 각 포인터가 가리키고 있는 대상체(object)의  데이터형이
T라고 할 때, 다차원 포인터 배열의 정의는 아래와 같다.

    T *arrayp[size1][size2]......[sizen];
                |      |            |
                +------+------------+------- 상수 수식이어야 한다.

    그런데 사용 빈도로 봐서 포인터 배열은 일차원일  경우가  태반이다.
문자열의 다차원 배열을 구현할 경우를 제외하고는 포인터 배열을  다차원
으로 만들 일이란 거의 없다.
    한편 포인터 배열의 초기화는 다차원 배열 포인터의 경우와  판이하게
다르다. 왜냐하면 포인터들의 배열이기 때문에 마땅히 배열요소인 각 포인
터들을 일일이 초기화해 주어야 하기 때문이다. 그 실례는 <예제 3>를  참
고하면 되겠다. 포인터 배열명인 ps에 다른 배열명을 아무런 생각없이  대
입해 버리는 누를 절대 범해서는 안 된다.
    그건 그렇다 치고 프로그래머라면 반드시 아래의 두 정의의  차이점을
명확하게 구분할 줄 알아야 한다.

    char (*pp)[3];
    char *pq[3];

    첫번째 것은 배열요소가 char형이고 크기가 3인 1차원 부분배열이  대
상체가 되는 포인터 pp를 정의한 것으로서, pp는 결국 이차원 배열 포인터
에 해당한다. 이 정의는 하나의 포인터 변수 pp를 정의한 것이므로 단지 2
바이트만의 메모리만이 소요된다.
    두번째 것은 char형 대상체를 가리키는 크기가 3인 포인터 배열  pq를
정의한 것이다. 이 정의는 배열요소인 세개의 포인터 pq[0], pq[1], pq[2]
를 위하여 총 2 * 3 == 6 바이트의 메모리를 필요로 한다.
    단지 괄호를 썼느냐 안 썼느냐에 따라서 이처럼 전혀 딴 판의  결과를
가져오므로 포인터를 정의할 때는 그 정의가 과연 자신이 원하는 포인터를
만드는 것인지 어쩐지를 신중을 기하여 재삼재사 확인해 보아야  할  것이
다. 그 이유는 만약에 포인터를 잘못 정의하여 사용한다 하더라도  무던히
도 관대한 C 컴파일러는 "Suspicious pointer conversion" 정도의  경고만
으로 때우고 나머지 부분의 컴파일을 성공적으로 수행해 버리기 때문이다.

  3.4 ragged 배열과 rectangular 배열

    앞에서 알아본 바와 같이 C에서 문자열 배열(string array)을  구현하
는 방법은 크게 두 가지로 나눌 수 있다.

---------------------------------------------------------------------
[1] 이차원 문자 배열로 문자열 배열을 구현한다.
    <예제 2>의 배열 s가 이에 해당된다.
[2] 문자를 가리키는 일차원 포인터 배열로 문자열 배열을 구현한다.
    <예제 3>의 배열 ps가 이에 해당된다.
---------------------------------------------------------------------

    문자열 배열을 위의 [1]번 방법으로 구현했을 때, 그  배열의  형태를
특별히 이름하여 "rectangular 배열"이라고 한다. 그 반면 문자열  배열을
[2]번 방법으로 구현했을 때는 그 배열의 형태를 "ragged 배열"이라고  부
른다. 즉 rectangular 배열은 이차원 배열의 한 종류이고, ragged  배열은
일차원 포인터 배열의 한 종류라고 보면 된다. 참고로 터보 파스칼의 문자
열 배열은 rectangular 배열에 속한다.

[그림 3]  문자열 배열의 2가지 구현 방법
---------------------------------------------------------------------

                  +-- ragged 배열 형태 ----------- 일차원 포인터 배열
     문자열 배열 -+
                  +-- rectangular 배열 형태 ------ 이차원 문자 배열

---------------------------------------------------------------------

    이처럼 문자열 배열은 두 가지 형태로 구현할 수 있기 때문에, 문자열
배열을 언급할 때에는 원칙적으로 문자열 배열이 ragged 배열 형태를 이루
고 있는지, 아니면 rectangular 배열 형태를 이루고 있는지 명시하는 것이
좋다.
    그러나 C에서는 메모리를 최대한으로 절약하기 위해 일반적으로  문자
열 배열을 ragged 배열로 구현하는 것이 보통이므로, 이 글에서는  특별한
언급이 없는 한 "문자열 배열은 ragged 배열"인 것으로 하겠다. 다시 말해
서,

    +-------------------------------------------------------+
    | "문자열 배열 == 문자열을 가리키는 일차원 포인터 배열" |
    +-------------------------------------------------------+

이라는 뜻으로 사용하겠다. 물론 어쩌다 혼동의 염려가 있을 때는 그 배열
의 형태를 직접 명시할 것이다.
    아래의 [그림 4]는 <예제 4>의 days 배열과 months 배열을 알기  쉽게
그림으로 표시한 것이다. [그림 4]를 보면 금방 알 수 있겠지만 months 배
열은 들쑥날쑥하고, days 배열은 바둑판 눈금 모양의  직사각형처럼  생겼
다. ragged와 rectangular라는 용어도 사실은 [그림 4]에서 볼 수 있는 배
열의 형태에서 유래된 말이다.

[그림 4] ragged 배열과 rectangular 배열의 개념도
---------------------------------------------------------------------

   [ ragged 배열 ]                              [ rectangular 배열 ]

 일차원 포인터 배열                               이차원 문자 배열
      months                                            days
    +-------+         +-----------+              +---+---+---+---+
[0] |       |   +-----| January\0 |       days[0]|   |   |   |   |
    +-------+   |     +-----------+              +---+---+---+---+
[1] |   o --+---+     +------------+      days[1]| S | U | N | \0|
    +-------+   +-----| February\0 |             +---+---+---+---+
[2] |   o --+---+     +------------+      days[2]| M | O | N | \0|
    +-------+         +---------+                +---+---+---+---+
[3] |   o --+---------| March\0 |         days[3]| T | U | E | \0|
    +-------+         +---------+                +---+---+---+---+


    +-------+         +------------+             +---+---+---+---+
[12]|   o --+---------| December\0 |      days[7]| S | A | T | \0|
    +-------+         +------------+             +---+---+---+---+
                            |                             |
                            |                             |
                    길이가 서로 다른               길이가 똑같은
                    문자열들의 배열에              문자열들의 배열에
                    적당함                         적당함

* 각 요일명과 월명을 첨자와 자연스럽게 일치시키기 위해 days[0]와 mont
  hs[0]는 사용하지 않았다.
---------------------------------------------------------------------

    어떤 경우에 rectangular 배열을 사용하고, 또어떤 경우에 ragged 배
열을 사용할 것인지의 선택상의 문제는 간단히 해결된다. <예제 4>의 월명
과 같이 배열로 만들고자 하는 각 문자열의 길이가 각각 서로 다르다면 ra
gged 배열로 구성하는 것이 메모리 절약상 단연 유리하다.
    반면에 <예제 4>의 요일명과 같이 문자열의 길이가 모두 똑같다면 rec
tangular 배열을 구성하는 것이 메모리 절약상 ragged 배열보다 다소 유리
하다. 하지만 이 경우에는 가급적 배열의 정의와 동시에 초기화를 해야만,
즉 그 배열의 선언문에서 초기화해야만 메모리를 낭비하지 않게 된다.
    <예제 4>의 days 배열처럼 strcpy 함수로 배열을 초기화하면 메모리상
에 동일한 문자열이 두 개씩 이중으로 존재하는 결과가 되어 대단한  낭비
가 아닐 수 없다. 물론 저장할 각 문자열의 길이가 수시로 변한다면  반드
시 넉넉한 크기의 rectangular 배열로 정의해야 한다는 점을 분명히  짚고
넘어가야 할 것이다.
    결론적으로 ragged 배열은 문자열 상수들의 배열을 만들 때 흔히 쓰이
는 형태라고 보면 거의 틀림없다.
    한편 <예제 4>는 두 배열(특히 days)을 정의와 동시에 초기화를  하지
않았기 때문에 메모리를 상당히 낭비하고 있다. 따라서 결코 잘 된 프로그
램이라고 할 수 없다. 그러므로 ragged 배열과 rectangular 배열을 정의하
는 방법을 서로 비교해 보고, 또한 [그림 4]를 이해하기 위한 임시방편 프
로그램으로 생각하기 바란다.

<예제 4> ragged 배열과 rectangular 배열의 비교
---------------------------------------------------------------------
void main(void)
{
    static char days[8][4];
    static char *months[13];
    int i;

    strcpy(days[1], "SUN");   -+
    strcpy(days[2], "MON");    |
    strcpy(days[3], "TUE");    | 이차원 문자 배열의 각 부분배열에
    strcpy(days[4], "WED");    | 문자열 상수들을 복사하여 초기화한다.
    strcpy(days[5], "THU");    |
    strcpy(days[6], "FRI");    |
    strcpy(days[7], "SAT");   -+

    months[1]  = "January";   -+
    months[2]  = "February";   |
    months[3]  = "March";      |
    months[4]  = "April";      |
    months[5]  = "May";        |
    months[6]  = "June";       |
    months[7]  = "July";       | 포인터 배열의 각 배열요소를
    months[8]  = "August";     | 초기화한다.
    months[9]  = "September";  |
    months[10] = "October";    |
    months[11] = "November";   |
    months[12] = "December";  -+

    for (i = 1; i <= 7; i++)
        printf("%-4s", days[i]);
    printf("\n");

    for (i = 1; i <= 12; i++)
        printf("%-10s", months[i]);
    printf("\n");
}
---------------------------------------------------------------------
실행 결과

SUN MON TUE WED THU FRI SAT
January   February  March     April    May    June    July    August
September October   November  December
---------------------------------------------------------------------


---------------------------------------------------------------------
  4  포인터의 포인터
---------------------------------------------------------------------

  4.1 포인터의 포인터를 써야 하는 이유

    포인터의 포인터를 설명하기 전에 먼저 그것을 써야하는 이유를  굳이
따지고 들면 크게 두 가지를 꼽을 수 있다.

---------------------------------------------------------------------
[1] 매개변수가 포인터 배열(문자열 배열)인 함수를 작성하기 위하여
[2] 명령행 인자(command-line argument)를 사용하기 위하여
---------------------------------------------------------------------

    이 중에서 두번째는 지면 관계상 설명하기가 곤란하기 때문에 이 글에
서는 첫번째에 관해 집중적으로 설명할 작정이다.

  4.2 포인터 변수의 포인터

    포인터의 포인터(pointer to potiner)는 그 대상체(object)가  포인터
인 포인터 변수를 지칭한다. 말이 다소 비비 꼬이는 기분이 들어 다시  풀
어서 얘기하자면, 포인터의 포인터는 그 포인터 변수가 가리키는 대상체가
포인터 변수, 포인터 배열이나 또다른 포인터인  포인터라는  뜻이다(역시
꼬인다).
    이 절에서는 포인터 배열을 매개변수로 취하는 함수를 정복하기  위한
전초 작업으로서 포인터의 포인터, 그 중에서도 포인터  변수의  포인터를
사용하는 방법 3단계를 알아 보도록 하겠다.

  4.3 제1단계: 정의

    예를 들어 어떤 포인터 pa가 T형 포인터라고 한다면 그것을  정의하는
방법은 아래와 같다. T는 원칙적으로 임의의 데이터형이지만, 여기서는 이
해하기 쉽도록 편의상 int형 같은 산술형(arithmetic type) 중의 하나라고
생각하면 된다.

    T *pa;

   이제 대상체가 T형인 포인터형, 즉 (T *)형을 새로이 P형이라고  하자.
그러면 대상체가 P형인 포인터 ppa를 아래와 같이 정의한다고 해도 아무런
문제가 없다. 왜냐하면 포인터의 대상체에는 전혀 제한이 없기 때문이다.

    P *ppa;

    이것으로서 포인터의 포인터 ppa의 정의는 거의 끝나가는 셈이다.  이
제는 단순히 위의 정의에서 P형을 미리 약속해둔 (T *)형으로  치환하기만
하면 된다. 치환할 때 구두점(punctuator)의 우선순위를 눈으로 직접 확인
할 수 있도록 하기 위해 괄호를 의도적으로 사용하였다.

    T *(*ppa);

    그러나 괄호를 생략하더라도 우선순위에는 변동이 없으므로 결국 아래
와 같이 된다. 드디어 ppa는 대상체가 T형 포인터(변수 또는 상수)인 포인
터 변수로써 정의된 것이다.

    +----------+
    | T **ppa; |
    +----------+

    포인터의 포인터를 정의하는 방법은 이와 같이 간단하다. 변수명  ppa
앞에 단지 **를 붙여 주기만 하면 그만인 것이다.
    마찬가지로 거의 쓰이는 일은 없지만, 예컨데 포인터의 포인터의 포인
터를 정의한다고 할 것 같으면, 변수명 앞에 ***를 붙이는 것 밖에 할  일
이 없다. 쉽게 말해서 "포인터..."라는 용어의 갯수 만큼 구두점 *를 변수
명 앞에 붙여 주면 된다. 당장 이해가 갈른지 모르겠는데 어쨌든 아래의 p
ppa는 "대상체가 T형 포인터의 포인터인 포인터 변수"이다?!??

    T *(*(*ppa));
    또는
    T ***pppa;

  4.4 제2단계: 초기화

    ppa를 초기화시키려면 우선 "초기화되어 있는 T형 포인터"가 마련되어
있어야 한다. 여기서는 아래와 같이 정의되고 초기화된 T형 포인터 변수 p
a를 가지고 ppa를 초기화하고자 한다.

    T *pa, a = 3;

    pa = &a; <--- pa의 초기화

    ppa는 대상체가 T형 포인터인 또다른 포인터 변수이므로, ppa에  대입
할 수 있는 값은 T형 포인터를 가리키고 있는 포인터여야 한다. 예컨데 pp
a에는 T형 포인터 변수 pa의 번지값을 대입해 주어야 한다. ppa에 T형  포
인터를 직접 대입하면 절대로 안 된다. 자세한 사항은 [표 1]을  참고하기
바란다.

---------------------------------------------------------------------
올바른 초기화  틀린 초기화   경고 메시지
---------------------------------------------------------------------
 ppa = &pa;     ppa = pa;   "Suspicious pointer conversion"
                ppa = *pa;  "Non-portable pointer assignment"
                *ppa = pa;  "Possible use of 'ppa' before definition"
                **ppa = a;  "Possible use of 'ppa' before definition"
                ppa = &&a;  Error: "Expression syntax"
---------------------------------------------------------------------

    이제 pa와 ppa의 초기화가 다 끝났다. [그림 5a]와 [그림 5b]를  참고
로 하여 ppa의 개념을 보다 확실히 해두기 바란다.

[그림 5a]  ppa가 초기화된 직후의 개념도
---------------------------------------------------------------------

    T형 포인터의 포인터      T형 포인터            T형 변수
           ppa                 pa                     a
        +-------+           +-------+             +-------+
        |   o --+---------->|   o --+------------>|   3   |
        +-------+ ppa = &pa +-------+   pa = &a   +-------+

---------------------------------------------------------------------

[그림 5b]  ppa가 초기화된 직후의 실제 상황
---------------------------------------------------------------------

    T형 포인터의 포인터      T형 포인터            T형 변수
           ppa                  pa                    a
        +-------+           +-------+             +-------+
        |  &pa  |           |   &a  |             |   3   |
        +-------+           +-------+             +-------+
        pa의 번지값이        a의 번지값이
        들어 있다.           들어 있다.

---------------------------------------------------------------------

  4.5 제3단계: 참조

    pa와 ppa를 제2단계를 통하여 초기화를 시키면 아래의 [표 2]에  나오
는 세 부류의 동등한(equivalent) 수식들이 생겨난다. [표 2]의 우측 열은
각각 가운데 열과 동등하기는 하지만 다소 억지생떼를 쓴 것이다. 우측 열
이 왜 가운데 열과 동등한지 그 이유를 곰곰히 따져 보기 바란다.

[표 2] 세 부류의 동등한 수식
--------------------+---------------------+--------------------------
T형 변수            |  a     *pa    **ppa |  *&a   **&pa 등등
--------------------+---------------------+--------------------------
T형 포인터          |  &a     pa     *ppa |  &*pa  &**ppa  *&pa 등등
--------------------+---------------------+--------------------------
T형 포인터의 포인터 |        &pa      ppa |  &*ppa &*&pa 등등
--------------------+---------------------+--------------------------

    [표 2]에서 가장 주목할 것은 **ppa와 a가 완전히 동등하다는 점이다.
따라서 언제 어디서나 **ppa는 a 대신에 쓸 수 있다. 물론 pa와 ppa가  다
른 값으로 변경되기 전까지만 그렇다는 얘기다.

<예제 5>  포인터의 포인터에 의한 참조
---------------------------------------------------------------------
#define printexpri(expr) printf("%-5s == %4d\n", #expr, expr)
#define printexprp(expr) printf("%-5s == %4p\n", #expr, expr)
                                                 |
void main(void)                                  +-- 전처리기 연산자
{                                   문자열 상수로 만든다.
    char a, *pa, **ppa;

    a = 3;
    pa = &a;
    ppa = &pa;

    printexpri(a);
    printexpri(*pa);
    printexpri(**ppa);

    printexprp(&a);
    printexprp(pa);
    printexprp(*ppa);

    printexprp(&pa);
    printexprp(ppa);
}
---------------------------------------------------------------------
실행 결과(절대 번지값은 상황에 따라 달라질 수 있음)

a     ==    3  -+
*pa   ==    3   +- 서로 동등하다.
**ppa ==    3  -+
&a    == FFDD  -+
pa    == FFDD   +- 서로 동등하다.
*ppa  == FFDD  -+
&pa   == FFDE  -+- 서로 동등하다.
ppa   == FFDE  -+
---------------------------------------------------------------------

  4.6 일차원 포인터 배열의 포인터

    포인터 배열의 포인터라는 것은 그 포인터의 대상체가 포인터  배열이
라는 뜻이다. 그러면 이제 포인터 배열의 포인터를 사용하는 방법을 늘 해
왔던 대로 3단계에 걸쳐서 알아보도록 하자.

  4.6.1 제1단계: 포인터 배열의 포인터 pps를 정의

    우선 아래와 같이 배열크기가 MAX이고 배열요소가 T형 포인터인  일차
원 포인터 배열 ps를 머릿속에 그려둔다.

    T *ps[MAX]

    그 다음에 제1첨자크기를 머릿속에서 삭제하는데, 여기서 ps는 일차원
배열이므로 MAX가 이에 해당된다.

    T *ps[]

    그리고 나서 ps[]를 (*pps)로 대치하여 선언문에 실제로 써넣는다.

    T *(*pps);

    이제 pps의 정의가 끝난 셈이다. 그런데 여기서 구두점인 괄호 (  )를
생략해도 그 우선순위에는 변동이 없으므로 결국 아래와 같이 된다.

    +----------+
    | T **pps; |
    +----------+

    여기서 우리는 한 가지 중요한 사실을 발견할 수 있다. 그것은  pps의
정의가 앞에서 설명한 포인터 변수의 포인터 ppa의 정의와 완전히  동일하
다(identical)는 점이다. 그 이유는 다음과 같이 해석할 수 있다.
    원래 "P형 배열 s를 가리키는 일차원 배열 포인터 ps"와 단순한  "P형
포인터 pa"의 정의 형식은 아래와 같이 완전히 동일하다. 단지 초기화  방
법이 다를 뿐이다.

    정의               초기화

    P s[MAX], *ps;     ps = s;  <--- 일차원 배열 포인터
    P a, *pa;  |       pa = &a; <--- 단순한 포인터
          |    |
          +----+------------- 정의 형태가 같다.

    그런데 P는 산술형뿐만 아니라 임의의 데이터형일 수  있으므로,  P를
(T *)로 대치해도 아무런 문제가 없다.

    정의                    초기화

    T *ps[MAX], **pps;      pps = ps;
    T a, *pa, **ppa;|       pa = &a; ppa = &pa;
                |   |
                +---+------------ 정의 형태가 같다.

    결과적으로 ppa와 pps는 그 정의 형식이 완전히 동일하다. 단지  그것
을 프로그래머가 포인터 변수의 포인터로 사용하느냐, 아니면 +, -, ++, -
- 등의 연산자를 씀으로써 포인터 배열의 포인터로 사용하느냐에 따라  그
의미가 달라질 뿐이다.

  4.6.2 제2단계: 포인터 배열의 포인터 pps를 초기화

    pps는 포인터 배열의 포인터이므로 pps에 대입할 수 있는 것은 그  포
인터 배열의 선두를 가리키는 포인터이다.
    포인터 배열의 선두를 가리키는 포인터는 [표 3]에서도 알 수  있듯이
배열명 ps나 &ps[0]에 의해서 얻을 수 있다. 배열명 ps를 pps에 대입할 수
있는 이유는 지난 달에 배운 "포인터 생성에 관한 정의 I" 때문이다.

[표 3] pps의 초기화 방법
---------------------------------------------------------------------
올바른 초기화  틀린 초기화    경고 메시지
---------------------------------------------------------------------
pps = ps;      pps = &ps;     "Suspicious pointer conversion"
pps = &ps[0];  pps = *ps;     "Suspicious pointer conversion"
               *pps = *ps;  "Possible use of 'pps' before definition"
               pps = &*ps[0]; "Suspicious pointer conversion"
---------------------------------------------------------------------

    각종 정의에 입각하여 pps = ps라는 대입식이 왜  적법한지에  대하여
따지는 작업은 11.2.3절에서 유추해보기 바라며 여기서는 생략하겠다.

  4.6.3 제3단계: pps에 의한 포인터 배열 ps의 참조

    pps에 의하여 ps를 참조하는 일은 매우 간단하다. 여지껏 누차 언급한
바와 같이 pps를 그저 ps 쓰듯이 하면 된다. 더 이상 쉽게 풀어서  얘기해
봤자 수다 떠는 일 밖에 안 될 같아서 이만 줄이겠다. 다만 pps에는  ++나
-- 연산자를 사용할 수 있다는 점을 잊지 말았으면 한다.

<예제 6> pps에 의한 포인터 배열 ps의 참조
---------------------------------------------------------------------
void main(void)     +----- 포인터 배열의 포인터를 정의
{                   |
    char *ps[3], **pps;
    int i; |
           +--- 포인터 배열의 정의
    pps = ps; <--- pps의 초기화

    pps[0] = "Breakfast\n";  -+
    pps[1] = "Lunch\n";       | pps에 의한 ps 참조
    pps[2] = "Supper\n";     -+

    for (i = 0; i < 3; i++)
        printf(pps[i]);
}               +---그저 ps 쓰듯이 쓰면 된다.
---------------------------------------------------------------------
실행 결과

Breakfast
Lunch
Supper
---------------------------------------------------------------------

[그림 6]  pps와 ps의 관계 개념도
---------------------------------------------------------------------

포인터 배열의 포인터
   pps
+-------+                                       길이가 일정치 않은
|   o   |                                       문자열 상수들
+---+---+          포인터 배열                 +---------------+
    |                  ps        +------------>| Breakfast\n\0 |
    | pps[0]       +-------+     |             +---------------+
    +---------->[0]|   o --+-----+             +-----------+
    | pps[1]       +-------+       +---------->| Lunch\n\0 |
    +---------->[1]|   o --+-------+           +-----------+
    | pps[2]       +-------+                   +------------+
    +---------->[2]|   o --+------------------>| Supper\n\0 |
                   +-------+                   +------------+

---------------------------------------------------------------------

  4.7 다차원 포인터 배열의 포인터

    다차원 포인터 배열의 포인터는 거의 사용되고 있지  않지만,  그래도
혹시 문자열의 이차원 배열을 구현할 필요가 있는 독자를  위하여  여기서
간략하게 이차원 포인터 배열의 포인터를 정의하는 방법만 알아보자.

---------------------------------------------------------------------
[1] 먼저 이차원 포인터 배열 pss를 머릿속에 그려둔다. 여기서 size1과 s
    ize2는 물론 상수수식이어야 한다.

    T *pss[size1][size2]

[2] 그리고 나서 최상위 부분배열의 크기(제1첨자크기 == size1)를 삭제한
    다. 만약에 함수의 매개변수 리스트에다가 선언하는 경우에는 다음 [4
    ]번으로 그냥 건너 뛸 수 있다. 그렇지 않다면 반드시 [3]번을 경유해
    야 한다.

    T *pss[][size2]

[3] pss[]를 (*ppss)로 대치한다.

    +-------------------+
    | T *(*ppss)[size2] |
    +-------------------+

    여기서 괄호 ( )는 절대로 생략하면 안 된다. 만약 **ppss[size2]처럼
    괄호를 생략해 버리면 구두점의 우선순위에  따라  **(ppss[size2])로
    인식되어, 원래 의도한 "이차원 포인터 배열의 포인터"가 아닌 엉뚱한
    "일차원 포인터의 포인터 배열"을 정의하게 된다?!??

[4] 선언부에 직접 기술한다.

    T *(*ppss)[size2], *pss[size1][size2];

[5] 초기화는 아래와 같이 하면 된다. 물론 이차원 포인터 배열 pss의  모
    든 배열요소도 일일이 함께초기화해 주어야 하지만 설명의 중복을 피
    하기 위해 여기서는 생략했다.

    ppss = pss;

[6] 이제 ppss를 그저 pss 쓰듯이 하면 된다. ppss가 pss와 다른 점이  있
    다면 변수의 일종이므로 ++나 -- 연산자를 쓸 수 있다는 점이다.
---------------------------------------------------------------------

    다차원 포인터 배열의 포인터를 사용한 예는 다음의 <예제 7>을  참고
하기 바란다.


---------------------------------------------------------------------
  5  매개변수가 포인터 배열인 함수
---------------------------------------------------------------------

    매개변수가 포인터 배열인 함수를 만드는 방법은 이 글 앞부분에 있는
매개변수가 다차원 배열인 함수를 만드는 방법에 준한다. 다만 형식매개변
수로서 포인터의 포인터를 선언하는 방법만 간단하게  여기서  언급하고자
한다. 포인터의 포인터는 아래와 같이 선언한다.

    +---------+          +-----------+
    | T **pps |   또는   | T *(*pps) |
    +---------+          +-----------+

    그런데 일전에 언급했듯이 함수의 매개변수 리스트 내에서만은  "(*포
인터명)"과 "포인터명[]"이 완전히 동일하다고 했다. 따라서 아래와  같이
(*pps)를 pps[]로 바꿔치기해도 된다.

    +----------+
    | T *pps[] |
    +----------+

    그리고 만약에 이차원 포인터 배열의 포인터 ppss라면 아래의  두가지
중에서 마음에 드는 걸로 골라 사용하면 되는데, 이해하기가 쉬운  두번째
것을 권하고 싶다. 아래 첫번째를 사용할 때 괄호 ( )는 절대로 생략할 수
없다는 사실에 주의하기 바란다. 또한 size2는 반드시 상수수식이어야  하
며 생략할 수 없다.

    +-------------------+    +------------------+
    | T *(*ppss)[size2] |    | T *ppss[][size2] |
    +-------------------+    +------------------+

<예제 7> 매개변수가 포인터 배열인 함수의 사용 예
---------------------------------------------------------------------
void printmenu(char *pps[], unsigned n);
void printmultimenu(char *ppss[][2], unsigned n);

void main(void)
{          +----------------------------- 일차원 포인터 배열
    char *ps[3], *pss[3][2];
                   +--------------------- 이차원 포인터 배열
    ps[0] = "Breakfast"; -+
    ps[1] = "Lunch";      | ps의 초기화
    ps[2] = "Supper";    -+

    pss[0][0] = "Bread";    -+
    pss[0][1] = "Milk";      |
                             |
    pss[1][0] = "Ramyun";    |
    pss[1][1] = "Kkagdugi";  | pss의 초기화
                             |
    pss[2][0] = "Rice";      |
    pss[2][1] = "Kimchi";   -+
              +-------------- 배열명을 지정한다.
    printmenu(ps, 3);│
    printmultimenu(pss, 3);
}        +----- 매개변수가 일차원 포인터 배열인 함수
         |
void printmenu(char *pps[], unsigned n)
{
    int i;

    for (i = 0; i < n; i++) printf("%-16s", pps[i]);
    printf("\n------------------------------------------\n");
}        +----- 매개변수가 이차원 포인터 배열인 함수
         |
void printmultimenu(char *ppss[][2], unsigned n)
{                                |
    int i;                       +----- 생략할 수 없다.

    for (i = 0; i < n; i++) printf("%-16s", ppss[i][0]);
    printf("\n");
    for (i = 0; i < n; i++) printf("%-16s", ppss[i][1]);
    printf("\n");
}
---------------------------------------------------------------------
실행 결과

Breakfast       Lunch           Supper
------------------------------------------
Bread           Ramyun          Rice
Milk            Kkagdugi        Kimchi
---------------------------------------------------------------------

    포인터의 포인터에 관한 설명은 이것으로써 마친다. 오늘은 이만 책을
덮고 이 다음 번에 나머지 부분을 계속 읽어나가기 바란다.


---------------------------------------------------------------------
  6  문자열 상수에 의한 배열의 초기화
---------------------------------------------------------------------

  6.1 문자열 상수에 의한 문자 배열의 초기화

    대입식 등등을 쓰지 않고 선언문에서 직접 배열을 초기화하는  방법에
는 여러 가지가 있지만, 문자 배열의 경우에는 초기화하는 방법이 한 가지
더 있다. 이 방법은 대단히 간단하고 또한 편리하기 이를 데 없는  방법인
데, 바로 문자열 상수로 직접 문자 배열을 초기화하는 것이다.
    문자열 상수는 일차원 문자 배열과 완전히 동등하다는 사실은  지지난
달에서 이미 언급했었다. 그러므로 일차원 문자 배열과 같은 내부  구조를
가지는 문자열 상수를 이용하여 다차원 문자 배열의 최하위  부분배열(1차
원)을 초기화하는 것은 문법상이나 논리상으로도 전혀 하자가 없다.
  예를 들어 아래의 5가지 초기화 방법은 완전히 동일하다. 문자열은 항
상 '\0'으로 끝난다는 사실에 주의하여야 한다. 즉 문자 배열의 크기는 널
종료문자를 저장하기 위하여 (문자열의 실제 길이 + 1)의 값을 가져야  한
다는 뜻이다. 이런 저런 생각하기가 정 귀찮으면 아예 배열크기를  생략해
버리면 될 것이다.

char s[] = {'W', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n', '\0'};
char s[11] = {'W', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n', '\0'};
char s[11] = {'W', 'a', 't', 'e', 'r', 'm', 'e', 'l', 'o', 'n', };
char s[] = "Watermelon"; <--- 제일 속 편한 방법               |
char s[11] = "Watermelon";                                여분의 쉼표

       문자 배열 s
      +---+---+---+---+---+---+---+---+---+---+---+
      | W | a | t | e | r | m | e | l | o | n | \0|
      +---+---+---+---+---+---+---+---+---+---+---+
       [0] [1] [2] [3] [4] [5] [6] [7] [8] [9] [10]

    위에 나열한 5가지 초기화 방법 중에서 어느 것이 가장 간결해 보이는
가? 날씨와 기호에 따라서 다소 다르겠지만 눈 딱 감고  생각해보면  단연
네번째가 물망에 오를 것이다.
    이차원 문자 배열의 경우도 이와 마찬가지이다. <그림 7a>의  4가지는
모두 동일한 초기화 방법이다. 제1첨자크기(행의 갯수)는 편의상 생략했으
며, 맨끝의 여분의 쉼표는 찍으나 마나지만 그래도 찍는 게 보기 좋다.

<그림 7a> 이차원 문자 배열 softdrink의 여러 가지 초기화 방법
---------------------------------------------------------------------

                 +----- 생략하면 안 된다.
                 |           +---------------+
char softdrink[][6] = {      |               |
    {'C', 'o', 'l', 'a', '\0',    },         |
    {'F', 'a', 'n', 't', 'a', '\0'},         |
    {'C', 'i', 'd', 'e', 'r', '\0'},         |
};                                 │        |
                       +---------------------+
char softdrink[][6] = {|                     | 여분의 쉼표
    {'C', 'o', 'l', 'a',      },             |
    {'F', 'a', 'n', 't', 'a', },             |
    {'C', 'i', 'd', 'e', 'r', },             |
};                          |  |             |
                            +--+-------------+
char softdrink[][6] = { 'C', 'o', 'l', 'a', '\0', '\0', 'F', 'a',
                 'n', 't', 'a', '\0', 'C', 'i', 'd', 'e', 'r', '\0'};

char softdrink[][6] = {"Cola", "Fanta", "Cider"};

---------------------------------------------------------------------

<그림 7b> softdrink가 초기화 된 직후의 상황
---------------------------------------------------------------------

  [0] [1] [2] [3] [4] [5]
              +---+---+---+---+---+---+
  softdrink[0]| C | o | l | a | \0| \0|
              +---+---+---+---+---+---+
  softdrink[1]| F | a | n | t | a | \0|
              +---+---+---+---+---+---+
  softdrink[2]| C | i | d | e | r | \0|
              +---+---+---+---+---+---+

---------------------------------------------------------------------

    위의 예에서도 알 수 있듯이 문자열 상수로 문자  배열을  초기화하는
경우에도 배열의 초기화 규칙이 그대로 적용된다. 즉 배열크기(다차원  문
자 배열이라면 마지막 첨자크기)를 지정했을 때, 문자열의  실제  길이(널
종료문자는 제외)가 배열크기보다 더 크면 에러가 발생하고, 작으면 그 남
는 배열요소를 모두 0으로, 즉 널 종료문자 '\0'으로 채운다는 것이다. 특
별히 위에서 sofrdrink[0]를 주목하기 바란다.
    그 밖의 문자열 상수에 의한 초기화 규칙에는 세세한 사항이 몇몇  있
지만 구차해서 생략하겠다. 대신 [그림 8]에 그 실례를 들어 놓았으니  참
고하기 바란다.

[그림 8] 문자열 상수의 길이에 따른 문자 배열의 내용
---------------------------------------------------------------------

char s[4] = "AB";        s
                        +---+---+---+---+
                        | A | B | \0| \0|
                        +---+---+---+---+

char s[4] = "ABC";       s
                        +---+---+---+---+
                        | A | B | C | \0| <--- 바람직한 방법
                        +---+---+---+---+

char s[4] = "ABCD";      s
                        +---+---+---+---+
                        | A | B | C | D | <--- 널 종료문자가 없으므로
                        +---+---+---+---+     완전한 문자열이 아니다.


char s[4] = "ABCDE";     "Too many initializers" 에러가 발생한다.


char s[] = "ABC";        s
                        +---+---+---+---+
                        | A | B | C | \0| <--- 가장 바람직한 방법
                        +---+---+---+---+


char ss[][4] = {"A", "BC"};
                        +---+---+---+---+
                        | A | \0| \0| \0|
                     ss +---+---+---+---+
                        | B | C | \0| \0|
                        +---+---+---+---+


char ss[][4] = {"ABCD", "EFGH"};

                        +---+---+---+---+
                        | A | B | C | D |
                     ss +---+---+---+---+
                        | E | F | G | H |
                        +---+---+---+---+

---------------------------------------------------------------------

    [그림 8]에서 char s[4] = "ABCD"나 char ss[][4] = {"ABCD", "EFGH"}
와 같은 선언문에는 주의할 필요가 있다. 이 경우 널 종료문자가 배열 s의
끝에 저장되지 않으므로 그 배열 s는 불완전한 문자열이 된다. 따라서 pri
ntf 함수 %s 서식으로 이런 불완전한 문자열을 가진 배열 s를 절대로 출력
해서는 안 된다.

  6.2 문자 배열과 포인터 배열의 초기화 구별

    문자 배열을 초기화하다 보면 자칫 이것을 포인터 배열의 초기화와 혼
동하게 되는 수가 더러 있다. 예를 들어 아래와 같은  두  선언문이  있을
때,

    char s[] = "ABCDE";
    char *ps = "ABCDE";

    이 두 선언문은 전혀 다른 것이라는 사실을 명확하게 알아야 한다. 첫
번째 선언문은 배열크기가 6인 일차원 문자 배열 s를 정의한 것이고, 두번
째 선언문은 문자열 상수 "ABCDE"를 가리키는 포인터 변수 ps를 정의한 것
이다.

[그림 9] s와 ps의 차이
---------------------------------------------------------------------

 s                                ps
+---+---+---+---+---+---+        +-------+
| A | B | C | D | E | \0|        |   o --+---+
+---+---+---+---+---+---+        +-------+   |
                                             |
                                             |
                                            +---------+
                                            | ABCDE\0 |
                                            +---------+

---------------------------------------------------------------------

    이와 같이 문자 배열과 포인터 또는 포인터 배열의 초기화 방법에  항
상 주의하면서 <예제 8>을 분석해보기 바란다. <예제 8>은 앞의 <예제  4>
를 수정한 것으로서 두 배열을 초기화하는 시점만이 다를 뿐 그  나머지는
똑같다.
    또한 "초기화가 배열의 정의와 동시에 이루어지므로 메모리의  낭비가
없는 것"이 특징이다. 단, 그 문자 배열의 기억부류(storage class)가  외
부형(external), 또는 정적(static)이어야만 메모리의 낭비가 없게  된다.
자동배열이면 함수 호출시마다 매번 초기화되어야 하기  때문에  메모리가
전혀 절약되지 않는다는 사실에 주의해야 할 것이다. 그런  까닭에  <예제
8>에서는 메모리의 낭비를 없애기 위하여 days나 months를 정적배열로  정
의했다.

<예제 8>  문자 배열과 포인터 배열의 초기화 비교
---------------------------------------------------------------------
#include <stdio.h> <--- 매크로 상수 NULL이 정의되어 있다.

void main(void)
{
    static char days[][4] = {    <--- rectangular 배열
        "", "SUN", "MON", "TUE",
        "WED", "THU", "FRI", "SAT",
    };
    static char *months[] = {   <--- ragged 배열
        NULL,                        실제값은 0이다.
        "January",   "February", "March",    "April",
        "May",       "June",     "July",     "August",
        "September", "October",  "November", "December",
    };
    int i;

    for (i = 1; i <= 7; i++)
        printf("%-4s", days[i]);
    printf("\n");

    for (i = 1; i <= 12; i++)
        printf("%-10s", months[i]);
    printf("\n");
}
---------------------------------------------------------------------
실행 결과

SUN MON TUE WED THU FRI SAT
January   February  March     April   May    June    July    August
September October   November  December
---------------------------------------------------------------------


---------------------------------------------------------------------
  7  끝으로
---------------------------------------------------------------------

    필자가 독자와 약속한 분량은 이것으로써 다했다. 어떤가? 이만하면 C
의 포인터도 별 것 아니라고 큰소리 칠 수 있을 것이다. 물론 지난  9월호
부터 4개월에 걸쳐 연재한 것만 제대로 소화해 냈을 때의 얘기다.
    지면 관계상 배열의 초기화 방법, 명령행 인자(command line  argumen
t)의 사용법, 함수 포인터(function pointer)의 사용법  등등을  언급하지
못한 것이 아쉽지만 어쨌든 이것으로서 길지도 짧지도 않은 "정복 터보 C"
연재를 마치고자 한다.
 
