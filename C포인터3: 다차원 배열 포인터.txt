 임인건   (turbo28 )
[강좌] C포인터3: 다차원 배열 포인터

작성 연월일: 1989.9.30, 10.2
마이크로소프트웨어 게재: 1989.11
HWP/TXT 변환: 1993.3.5

                         >>> 정복 터보 C <<<

    제3회  실매개변수를 변경하는 함수와 다차원 배열 포인터의 정복

                   글/임인건 (서울대 기계공학과3)


---------------------------------------------------------------------
  1  본론에 앞서
---------------------------------------------------------------------

    찌르면 터질듯한 푸른 하늘의 지난 10월을 과연 허무함없이  의미있게
보냈는지 모르겠다. 뭐 거창하게 인생 전체를 대국적으로  걸고  넘어지지
않더라도 자기 자신의 생활을 그날그날 뜻있게 보내는 방법에는 여러 가지
가 있을 수 있다. 예컨데 지금 한창 때가 무르익은 젊은이라면 아마  10월
을 연인(들)과 함께 풋풋한 마음을 나누며 꿈꾸듯이 보내고  싶었을  것이
다.
    하지만 필자를 위시하여 지금 이 책을 읽고 있는 독자들은 대개  그런
나날이 여의치 않았을 것으로 본다. 물론 마음이야 눈 앞을 날쌔게 스쳐가
는 한 마리 제비가 되고픈 심정이 굴뚝 같겠지만, 지금껏  정든  컴퓨터를
눈 앞에 두고서 다른 데다가 슬며시 한눈을 판다는 것이 그리 쉬운 일만은
아닐 것이다.
    아뭏튼 자의든 타의든 간에 제비처럼 날라 다니기가 곤란하다면, 우리
는 미련없이 본연의 자리로 돌아가서 우리의 충직한 컴퓨터의 도움에 힘입
어 앞으로 한 달 가량 남은 11월이 남들 못지 않게 의미있도록 노력해야겠
다. 그러기 위해 C의 포인터 정복을 목표로 11월 한 달 고군분투하는 것도
분명 실속 꽤나 차리는 일이지 싶다.


---------------------------------------------------------------------
  2  포인터 참조에 의한 실매개변수의 변경
---------------------------------------------------------------------

    지난 달 연재에서 포인터 변수의 정의 방법과 함수의 실매개변수(actu
al parameter == argument)를 변경하는 함수를 작성하는 방법을  설명하지
않은 관계로 그 글을 이해하는데 어려움이 있었지 않나 싶어서 이번  기회
에 자세히 언급하고자 한다.

  2.1 실매개변수를 변경하려면

    함수를 쓰다 보면 함수를 가지고 실매개변수를 직접 변경하고자 할 경
우가 종종 생긴다. 가장 전형적인 예가 두 변수의 값을 서로 교환하는  것
이다. 두 변수 x, y의 값을 서로 교환하려면 대개 다음과 같이 한다. 이때
temp라는 임시변수를 써야 한다.

      temp = x; <--- x에 있는 값을 temp에 넣고
      x = y;    <--- y의 값을 x로 보내고
      y = temp; <--- 이제 temp에 보관 중인 원래의 x값을 y에 넣는다.

    이제 두 변수의 값을 교환하는 함수를 한 번 만들어보자. 일단 아래와
같이 만들었다. 과연 이 함수를 써서 double형의 두 변수 a, b의 값을  교
환할 수 있을까?

    함수 정의:
    void swapdouble(double x, double y)
    {                      |         |
        double temp;       +---------+----- 형식매개변수
                                            (실매개변수의 복사판)
        temp = x;
        x = y;
        y = temp;
    }

    함수 호출:
    swapdouble(a,  b);
               +---+----- 실매개변수

    예상은 했겠지만 a, b의 값은 전혀 교환되지 않는다. 왜냐하면 x, y는
실매개변수의 복사판인 형식매개변수(formal parameter)일 뿐이기  때문이
다. C는 파스칼과 마찬가지로값에 의한 호출(call by value) 방식에 의해
매개변수를 함수에 건네 주기 때문에 함수 내에서 형식매개변수를  제아무
리 변경하더라도 원래의 실매개변수의 값은 전혀 바뀌지 않는다.
    이럴 때 파스칼이었다면 아래와 같이 예약어 var를 써서 형식매개변수
를 선언했을 것이다. 그렇다면 C에서는 어떻게 선언해야 할까? 나중에  설
명하겠다.

    파스칼:
    procedure SwapReal(var x, y:Real)
    var
      Temp: Real;
    begin
      Temp := x;
      x := y;
      y := Temp
    end;

  2.2 번지 연산자 &의 의미

    C에서 아래의 수식은 도대체 뭘 하자는 것일까?

    &x

    여기서 &는 비트 AND 연산자가 아니고 단항(unary)  연산자의  일종인
번지 연산자(address operator)이다. 그래서 간단하게 단항 &  연산자라고
도 한다.
    단항 & 연산자의 피연산자가 될 수 있는 것은 좌변값이다. 좌변값(lva
lue)이란 무엇이건 값을 대입할 수 있는 것, 즉 메모리상에 저장되어 있으
며 대입 등의 조작이 가능한 것을 말한다. 쉽게 말해서 좌변값은 대입  연
산자 =의 좌변에 올 수 있는 값이라 여기면 틀림없다.
    포인터 변수를 포함하여 모든 변수는 좌변값이다. 좌변값이 될 수  없
는 것은 수식이나 상수(문자열 상수, 배열 상수 포함) 등등이다. 수식이나
상수에다 값을 대입할 수는 없는 노릇 아닌가?
    다시 본론으로 되돌아가서, &x가 뜻하는 바는 어떤 변수 x가 저장되어
있는 곳의 선두번지값이다. 지난 10월호의 [그림 1]을 기억하고  있으리라
믿는다. 포인터는 곧 번지라는 사실 말이다. 그러므로 번지 연산자의 결과
값은 번지값, 곧 포인터이며 이 말은 &x를 적절한 포인터 변수에다 대입해
줄 수 있다는 뜻이다. 그러면 번지값을 대입하는데 필요한 포인터  변수를
정의하는 방법에 대하여 알아보자.

  2.3 포인터 변수의 정의와 번지값의 대입

    포인터 변수 중에서 특별히 문자열 포인터 변수를 정의하는 방법은 이
미 지난 10월호에서 설명한 바 있다. 다른 포인터 변수를 정의하는 방법도
이와 유사하다. 구두점 *를 포인터 변수명 바로 앞에다  덧붙이기만  하면
되는데 다음과 같은 순서를 밟아 포인터 변수를 정의하면 틀림없다.

---------------------------------------------------------------------
[1] 번지값을 취하고자 하는 변수의 선언문을 머릿속에 떠올린다.  일반적
    으로 변수의 데이터형이 T형일 때 아래와 같이 정의했을 것이다.

    T variable;

[2] 머릿속에 떠올린 선언문에서 변수명 variable을 포인터 변수명  ptr로
    대치하고 T와 ptr 사이에 구둣점 *를 삽입한다. 이때 *는  관습적으로
    ptr쪽에 붙인다. 이때 필요하면 ptr에 괄호를 써야 한다.

    T *ptr;    또는    T *(ptr);
---------------------------------------------------------------------

    이상과 같이 [1]~[2]단계를 거치면 T형 포인터 변수 ptr의 정의가  완
결된다. 각종 산술형 포인터 변수의 예를 들어 보면 아래와 같다.

    int *pi;         <--- int형 포인터 변수 pi를 정의
    double *px;      <--- double형 포인터 변수 px를 정의
    char *ps;        <--- char형 포인터 변수 ps를 정의
                          문자열 포인터 변수를 정의하는 방법과 동일함
    unsigned char *pc; <- unsigned char형 포인터 변수 pc를 정의

    이 때 일반적으로 T형 포인터 변수라는 말은 그 포인터 변수에 대입할
수 있는 값이 T형 대상체(object, 예컨대 T형 변수)의 선두번지값을  의미
한다는 사실임을 유념하기 바란다. 다만 포인터의 종류를 총칭하는데 쓰이
는 용어인 문자열 포인터(문자 포인터), 정수 포인터, 배열 포인터,  포인
터의 포인터 등등에서는 편의상 접미사 '-형'을 생략하기로 한다.

    이제 &x의 값을 포인터 변수에 대입해보자. 그런데 C에서는  번지값을
아무 포인터 변수에나 무작정 대입하는 것은 최대한으로 피하는 것이 좋다
(터보 C 컴파일러가 그렇게 하도록 가만 놔두지도 않는다). 즉 int형 변수
의 번지값은 반드시 int형 포인터 변수에 대입해야 하며, 마찬가지로 doub
le형 변수의 번지값은 반드시 double형 포인터 변수에만 대입해야 한다.

[그림 1] 대입식 px = &x의 의미(실제 상황)
---------------------------------------------------------------------

      대입 과정

            px                     x(8바이트 크기)
        +--------+               -+-+-+-+-+-+-+-+-+-
        |        |<--------+     -+++-+-+-+-+-+-+-+-
        +--------+         +-------+
                      x의 선두번지값이 px에 대입된다.

      대입 결과

            px                           x
        +--------+               -+-+-+-+-+-+-+-+-+-
        | 번지값 |               -+-+-+-+-+-+-+-+-+-
        +--------+

---------------------------------------------------------------------

    [그림 1]과 같이 대입식 px = &x를 수행한 후, double형 포인터  변수
px에는 double형 변수 x의 선두번지값이 저장된다. 이 말을 포인터 개념을
써서 표현한다면,

    +--------------------------------------------------------+
    | "double형 포인터 변수 px는 double형 변수 x를 가리킨다" |
    | 또는 간단히 "포인터 px는 변수 x를 가리킨다"            |
    +--------------------------------------------------------+

라고 할 수 있다. 이 말을 그림으로 나타내면 [그림 2]와 같다.

[그림 2] "px는 x를 가리킨다."의 개념도
---------------------------------------------------------------------

           px                            x
        +-------+                -+-+-+-+-+-+-+-+-+-
        |   o --+--------------->-+-+-+-+-+-+-+-+-+-
        +-------+

---------------------------------------------------------------------

  2.4 간접지정 연산자 *의 의미

    이제 아래의 수식이 뜻하는 바를 알아보자.

    *px

    여기서 *는 곱셈 연산자 *가 아니다. 또한 포인터 변수를  정의할  때
쓰는 구둣점 *도 아니다. 여기서의 *는 간접지정 연산자(indirection oper
ator)라고 불리우는 단항 연산자의 일종이다.
    단항 * 연산자의 피연산자는 언제나 포인터(번지값)이어야  한다.  즉
포인터 변수나 각종 포인터 수식이어야 한다. 단항 * 연산자(단항 별표 연
산자로 읽을 것)가 하는 일은 그 포인터가 가리키고 있는 번지에 저장되어
있는 내용을 읽어내는 것이다. 이때 읽어내고 또한 저장하는 일을 "참조(r
eference)"라는 용어로 표현한다. 그 읽어낸 내용은 단항 * 연산식의 결과
로 취해진다.
    단항 * 연산자는 피연산자인 포인터(변수 또는 수식)가 무슨형 포인터
이냐에 따라 각각 다르게 행동한다. 즉 포인터가 가리키고 있는  선두번지
에서부터 그 "무슨형"의 바이트 크기만큼만 읽어내는 것이다.  예를  들어
피연산자가 double형 포인터라면 선두번지부터 8 바이트만큼 읽어낸다. 그
렇다면 왜 1바이트가 아니라 8바이트씩이나 읽어내야 하는가?
  px가 가리키는 대상체(object)는 double형 변수 x이며 px는 현재 변수
x의 선두번지값을 가지고 있다. 이때 px가 가리키고 있는 번지에서 출발하
여 8바이트까지의 메모리에는 무엇이 저장되어 있는가? 바로 변수 x의  값
이 저장되어 있지 않은가!
    따라서 *px라는 포인터 수식은 결과적으로 변수 x의 값을  메모리에서
읽어내는 셈이 된다. 그러므로 변수 x의 값과 포인터 수식 *px의 값은  완
전히 서로 같을 수 밖에 없다. 이처럼 포인터를 쓰면 어떠한 변수(좌변값)
라도 그 값을 "간접적으로" 읽어낼 수(참조할 수) 있다는 것이 핵심  사항
이다.

[그림 3] *px의 의미
---------------------------------------------------------------------

      double형 포인터 변수             double형 변수
              px                             x
          +-------+                 -+-+-+-+-+-+-+-+-+-
          |   o   |                 -+-+-+-+-+-+-+-+-+-
          +---+---+
              |        수식 *px       | | | | | | | |   참조
              +-----------------------+-+-+-+-+-+-+-+

                                      | | | | | | | |   읽어냄
                                     +++++++++++++++++
                                     +-+-+-+-+-+-+-+-+  수식의 결과
  * 단항 * 연산자는 px가 가리키는
  * 번지부터 8바이트 만큼의 내용을 읽어낸다.
  * 이 8바이트의 내용은 double형
  * 값으로 취급된다.

---------------------------------------------------------------------

    여기까지 그런대로 파악했으면 아래의 두 수식을 지금쯤은 완전히  이
해할 수 있을 것이다. x, y가 double형 변수이고 px가 double형 포인터 변
수일 때,

    px = &x; <--- x의 번지값을 px에 대입한다.
    y = *px; <--- px가 가리키는 위치의 내용(8바이트)을
                  읽어내어 y에 대입한다.

    결국 위의 두 수식은 무엇을 뜻하는가? 결과적으로는 y = x라는  하나
의 대입식과 다를 바 없지만 그 대입 과정이 전혀 다르다. 즉 위의 두  수
식은 x의 값을 변수 y에 직접적으로 대입하는 대신 포인터 px를 통해 간접
적으로 대입하는 방법을 썼다. 직접과 간접의 차이에 주목해야 할 것이다.
그 차이는 포인터를 쓸 줄 아느냐 모르냐의 차이와 진배없다.

  2.5 *px는 변수로 취급된다

    원칙적으로나 상식적으로 볼 때 어떠한 연산자(물론 [ ]나 .같은 기본
연산자는 제외)라도 대입 연산자 =의 좌변에 결코 나타날 수 없다는  사실
은 지당한 얘기이다. 예컨데 a + b = 3이라는 대입식은 구문 에러를  유발
한다.
    그러나 단 한 가지 예외가 있다. 단항 * 연산자는 =의 좌변에  나타날
수 있다. 그렇다면 = 좌변에 있는 *는 이미 간접지정 연산자로서의 본래의
역할이 아닌 또 다른 역할을 하고 있다고 보는 것이  타당하다.  그렇다면
아래의 대입식은 무엇을 의미하는 것일까?

    *px = 3.14;

    위의 대입식은 정확하게 다음과 같은 뜻을 가지고 있다.

    "double형 포인터 변수 px에 저장되어 있는 번지값을 참조하여 그  번
    지부터 8바이트 크기의 메모리에 부동 상수 3.14를 저장한다."

    이 말을 포인터의 개념을 써서 간결하게 다시 표현하면 다음과 같다.

    "포인터 px가 가리키는 번지에 3.14를 저장한다."

[그림 4] 대입식 *px = 3.14의 의미
---------------------------------------------------------------------

        double형 포인터 변수          double형 변수
                px                          x
            +-------+             -+-+-+-+-+-+-+-+-+-
            |   o   |             -+-+-+-+-+-+-+-+-+-
            +---+---+                                 
                |                   | | | | | | | |  참조
                +-------------------+-+-+-+-+-+-+-+

                                    | | | | | | | |  저장함
                                   +++++++++++++++++
                                   +-+-+-+-+-+-+-+-+ 부동 상수 3.14
  * px가 가리키는 번지에
  * 8바이트 크기의 부동 상수
  * 3.14를 저장한다.

---------------------------------------------------------------------

    위의 말을 잘 음미해 보면 *px는 마치 값을 대입할 수 있는 변수(좌변
값)와 마찬가지로 취급된다는 사실을 알 수 있다. 이 때문에 *px는 대단한
응용성을 가지게 된다. 그것은 변수(좌변값)가 쓰일 수 있는 곳이라면  어
디든지 다 *px가 쓰일 수 있기 때문이다. 어쨌거나 [그림 4]에 보였듯이 *
px = 3.14는 x에 3.14를 직접 대입하는 것과 같은 결과를 가져옴을 알  수
있을 것이다(물론 그 대입 과정은 전혀 다름).

   직접 대입    같은 결과    간접 대입

    x = 3.14;     ------    px = &x;    <---- x의 번지값을 px에 대입
                  ------    *px = 3.14; <---- 그 번지에 3.14를 저장

    한편 수식 *px의 데이터형은 px가 무슨형 포인터인가에  따라  달라진
다. 여기서는 px가 double형 포인터 변수이므로 *px는 마치 double형 변수
인 것처럼 취급된다. 따라서 *px에 대입하고자 하는 값이 double형이 아닐
경우에는 산술 변환(arithmetic conversion) 규칙에 따라서  double형으로
자동 변환되어 *px에 대입된다.
    이제 "double형 포인터 변수 px가 가리키는 번지부터 8바이트  영역에
부동 상수 3.14를 저장한다"라는 말을 간단히 "*px에 3.14를  대입한다"라
는 말로 대신할 것이니 용어에 착오없기 바란다. 그리고 앞으로 "double형
포인터 변수 px"라는 용어 대신에 가급적이면 "double형  포인터  px"라는
용어를 사용하겠으니역시 착오없기 바란다.
    이해가 잘 안 되면 시간을 두고 천천히 지금까지의 내용을 다시  한번
음미해 보기 바란다. 이해가 안 된다고 조급해 하거나 급하게  서두를  건
없다(다시 읽으면 되니까). 다행히 이해가 되었다면 아래 왼편 다섯  문장
이 의미하는 바를 완전히 파악할 수 있을 것이다. 여기서 x, y, temp가 do
uble형 변수이고 px, py가 double형 포인터 변수일 때,

    px = &x;                     temp = x;
    py = &y;           ----      x = y;
    temp = *px;        ----      y = temp;
    *px = *py;
    *py = temp;

    왼편과 오른편 두 수식들 모두가 결과적으로는 x와 y의 값을 서로  교
환하는 일을 해준다. 그렇다면 차라리 오른편과 같이 x, y를 직접 써서 처
리하지 무엇하러 복잡하게 포인터를 써서 처리하는가 하면 바로 "포인터를
쓰면 간접적으로 x, y의 값을 변경할 수가 있다"는 점 때문이다. 이  점을
이용하여 비로소 함수의 (가상적인) 실매개변수의 값을  (간접)  변경하는
효과를 얻을 수 있다.

  2.6 실매개변수를 변경시키는 함수의 정의 방법

    이제 실매개변수를 변경하는 함수를 만들기 위한 사전 지식을 모두 갖
춘 셈이다. 그렇다면 swapdouble 함수를 다시 만들어 보자.

-----------------------------------------------
 함수 정의(만드는) 방법
-----------------------------------------------
void swapdouble(double *px, double *py)
{
    double temp;

    temp = *px;
    *px = *py;
    *py = temp;
}
-----------------------------------------------
<사용 예 1> a, b가 double형 변수일 때

a = 1.0;   +---+---번지 연산자를 써야 한다.
b = 2.0;   |   |
swapdouble(&a, &b);
-----------------------------------------------
<사용 예 2> pa, pb가 double형 포인터 변수일 때

a = 1.0;
b = 2.0;
pa = &a;   +---+-----번지 연산자를 쓰면 안 된다.
pb = &b;   |   |
swapdouble(pa, pb);
-----------------------------------------------
결과

값이 서로 바뀌어 a는 2.0, b는 1.0으로 된다.
-----------------------------------------------

    <사용 예 1>을 보면 swapdouble 함수를 호출할 때 실매개변수로 &a, &
b를 사용했다. 이것은 a, b의 값을 함수에 그대로 전달하는 것이 아니라 a
와 b가 저장되어 있는 곳의 선두번지값을 함수에 전달하는 것이다.
    이제 swapdouble 함수는 실매개변수로 지정한 포인터 수식 &a와  &b의
값을 형식매개변수 px, py에 복사받아서, 함수 내에서는 px, py를  가지고
일을 처리한다. 이때 px, py도 역시 복사받은 값에 불과하므로 px, py  자
체를 변경하는 것은 실매개변수 &a, &b와 아무런 상관이 없다. 사실  실매
개변수가 수식이므로 변경할 수도 없다.
    그러나 *px, *py를 변경하는 것은 어떤 결과를 가져올까? 앞에서 심도
있게 설명한 바 있듯이 (형식매개)변수 px, py가 &a, &b라는  번지값(포인
터)을 복사받아 보관하고 있으므로 *px, *py는 결국 *(&a), *(&b)가  되는
셈이고, 이것에 어떤 조작을 가한다는 것은 곧 간접적으로 변수 a, b의 값
을 변경하는 결과를 가져온다.

    이상과 같이 C가 함수에 매개변수 전달하는 방식인 값에 의한 호출(ca
ll by value) 원칙에 전혀 어긋남이 없이 여전히 실매개변수 &a, &b는  변
경되지 않았다. 다만 포인터에 의한 간접지정(indirection)에 의하여 변수
a, b가 원격 조정으로 변경되었을 뿐이다.
    여하튼 간에 마침내 함수 호출 swapdouble(&a, &b)에 의하여 변수  a,
b의 값이 변경(교환)되었다. 이때 관습상 앞으로는 &a, &b가 아니라 a,  b
를 실매개변수로 가정하기로 하자. 이렇게 단항 & 연산자를 제외한 a, b를
편의적인 실매개변수로 간주하자고 약속하면 "swapdouble 함수에 의해  실
매개변수 a, b가 변경되었다"라는 말을 할 수 있게 된다. 이제부터는 실매
개변수를 변경한다는 말이 용어 의미대로의 실매개변수를  변경하는  것이
아니라 포인터가 가리키는 가상적인 실매개변수를 변경하는 것임에 유념하
기 바란다.
 한편 <사용예 2>는 <사용예 1>과 완전히 동일한 결과를 가져온다. swa
pdouble 함수에 실매개변수를 지정할 때 왜 pa, pb 앞에다 단항 &  연산자
를 쓰지 않았을까? 그 이유는 이미 pa, pb 자체가 포인터 변수로서 번지값
을 가지고 있기 때문이다. 즉 pa == &a, pb == &b이므로 pa, pb에는  단항
& 연산자를 더 붙일 필요도 없고 붙여서도 안 된다.

---------------------------------------------------------------------
 실매개변수를 변경하는 함수를 정의하는 방법(만드는 방법)
---------------------------------------------------------------------

    함수를 정의할 때 변경하고자 하는 (가상적인) 실매개변수에 대응하는
형식매개변수를 포인터 변수로 선언한다. 예컨대 그 실매개변수의  데이터
형이 T형이면 형식매개변수를 T형 포인터로 선언한다.
    그런 다음 함수를 호출할 때 변경하고자 하는 (가상적인)  실매개변수
에 번지 연산자 &를 붙인다. 참고로 포인터 변수명에는 대개 접두사나  접
미사로 'p'를 덧붙이는 것이 관례이다.

    매개변수 리스트의 예            실제 호출 예   변경되는 대상

    void func(int *pa, int *pb)      func(&a, &b)    a, b
    void test(int a, double *px)     test(a, &x)     x
    void copy(double x, double *py)  copy(x, &y)     y

    실매개변수를 변경하려면 포인터인 형식매개변수 앞에 간접지정  연산
자 *를 써서 거기에 원하는 수식을 대입하면 된다.

예) 곱셈 연산자 -----+ +------- 간접지정 연산자
                     | |
           *pa = *pb * *pb; (곱셈 연산자와 간접지정 연산자를 구분)
           *px = (double)a;
           *py = x;
---------------------------------------------------------------------

    이와 같이 실매개변수를 복사하지 않고 대신 그 실매개변수를  가리키
는 포인터(번지값)를 함수에 전달하는 방식을 "참조에 의한 호출(call  by
reference)"이라고 한다. 그러나 거듭 반복하여 강조하지만 C에서는  참조
에 의한 호출도 어차피 값에 의한 호출(call by value)에 의하여 구현되는
것 뿐임을 유의해야 한다. 그것은 포인터(번지값) 자체도  역시  복사되어
함수로 전달되기 때문이다.
    따라서 (가상적인) 실매개변수를 변경하기 위해 함수에  그  포인터를
전달하는 것은 어디까지나 전적으로 프로그래머의 책임이다. C가 제  스스
로 포인터를 챙겨서 전달해주는 일은 절대 없다. 즉 C는 프로그래머가  시
키는 대로만 할 뿐이다. 만약에 포인터를 건네주는데 필요한 단항 &  연산
자를 실수로 빠뜨리거나, 아니면 필요없는데 쓸데없이 괜히 덧붙여서 모종
의 심각한 사태가 발생한다 할지라도 (특히 scanf 함수 사용시) 그것은 프
로그래머가 얼빠진 형광등이라서 그런 것이지 C가 허술하고 무능해서 그런
것은 결코 아니라는 점을 재삼재사 강조하고 싶다.


---------------------------------------------------------------------
  3  다차원 배열 포인터의 개요
---------------------------------------------------------------------

  3.1 다차원 배열 포인터란?

    우리는 이미 지난 달과 어제쯤에 포인터의 기초를 거의  대부분  배웠
다. 기초치고는 쉽지가 않아서 개념 잡기가 영 힘들다고 할 지도 모르겠으
나 이제부터와 다음 달에 비하면 그 정도는 새발의 피다.
    이제는 C 언어의 문법 체계 전체를 통틀어서 가장 힘든 난공불락의 요
새이자 태초의 카오스를 방불케 하는 혼돈의 연속인 "다차원 배열과  포인
터와의 관계"에 대하여 알아볼 차례이다. 제일 먼저 다차원 배열이라는 개
념 자체를 뿌리채 뒤흔드는 작업부터 착수하겠다.
    그 이전에 먼저 이 글 전체에 걸쳐 두루 쓰일 배열 x, y, z의  정의에
대하여 언급하겠다.

    int x[3];       <--- 일차원 배열의 정의
    int y[3][2];    <--- 이차원 배열의 정의
    int z[3][2][2]; <--- 삼차원 배열의 정의

    아울러 잠시 후 설명하겠지만 각 배열에 대응하는 배열 포인터 px,  p
y, pz의 정의도 참고하기 바란다.

    int *px;         <--- 일차원 배열 포인터의 정의
    int (*py)[2];    <--- 이차원 배열 포인터의 정의
    int (*pz)[2][2]; <--- 삼차원 배열 포인터의 정의

    이 글에서 예로 들고 있는 모든 배열과 배열 포인터는 위의 6가지  뿐
이므로, 설명의 편의를 위해서 배열 x, y, z나 배열 포인터 px, py,  pz의
정의를 일일이 밝히지 않을 테니 앞으로 혼동 없기 바란다. 또한 배열  포
인터 px, py, pz는 아래와 같이 미리 초기화되어 있다고 가정한다.

    px = x;
    py = y;
    pz = z;

    별도의 언급이 없는 한, 포인터 변수 px, py, pz는 언제나 위와  같이
초기화되어 있다고 가정하고 설명을 해나갈 것이기 때문에 포인터 변수  p
x, py, pz의 초기치를 일일이 밝히지 않을 것이다. 그러니까 본문  중에서
px, py, pz가 초기화되지 않고서 쓰였다는 오해는 삼가해 주었으면 한다.

  3.2 배열의 배열과 부분배열

    C에서 다차원 배열은 문법적으로 흔히 배열의  배열이라고  불리운다.
그것은 순전히 아래의 2가지 이유 때문이다.

---- 배열의 전모 ----------------------------------------------------

[1] C는 일차원 배열만을 지원한다. 본래 의미대로의 다차원  배열은  C에
    전혀 존재하지 않는다. 또한 배열크기는 반드시 컴파일할 때,  상수와
    마찬가지로 고정적(fixed)이어야 한다. 즉  배열크기(각  첨자크기)는
    배열의 정의에서 어떠한 방법으로든 반드시 미리 알려져야 한다.
[2] 그 대신 배열요소의 데이터형에는 제한이 없다.
---------------------------------------------------------------------

    위에서 [1]번 귀절은 어떻게 보면 아주 황당한 문구라고도 볼  수  있
다. 그도 그럴 것이 모든 언어에 기본적이고 필수적인 다차원 배열이 막강
한 C 언어에 존재하지 않는다니 말도 안 되는 소리로 들리지 않을 수 없을
것이다.
    그러나 [2]번 귀절을 자세히 읽어보면 그게 그렇지만도  않다는  것을
눈치챌 수 있다. 배열요소의 데이터형에 제한이 없다는 말은 곧, 일반적인
변수는 물론이고 배열 그 자체도 배열요소로 취할 수 있다는 의미로  해석
할 수 있다. 따라서 그 배열요소 자체가 배열인 일차원  배열로서  다차원
배열을 구현(simulate)할 수 있는 근거를 발견하게 된다. 이때 결과적으로
는그렇더라도 C는 다차원 배열이라는 개념을 전혀 모를 뿐만 아니라 지원
하지도 않는다는 점을 꼭 잊지 말아야 한다.
    이로써 C에서 다차원 배열을 "배열의 배열(array  of  arrays)"이라고
부르는 이유를 대강 짐작할 수 있으리라 믿는다. 지금까지 설명했듯이  배
열의 배열이라는 말은 "배열요소가 배열"이라는 의미를 가지고 있다. 이때
그 배열요소로서의 배열을 "부분배열(subarray)"이라고 부른다. 예를 들어
이차원 배열에서는 [그림 11.1-1]과 같이 이차원 배열을 구성하는  각각의
1차원 배열들이 곧 부분배열이다.

[그림 5] 부분배열의 개념
---------------------------------------------------------------------

                                 3x2 배열 y
             +-------+-------+-------+-------+-------+-------+
             |       |       |       |       |       |       |
             +-------+-------+-------+-------+-------+-------+
  배열요소    [0][0]   [0][1]  [1][0]  [1][1]  [2][0]  [2][1]
              |             |  |            |  |            |
              +-------------+  +------------+  +------------+
               부분배열 y[0]   부분배열 y[1]    부분배열 y[2]

---------------------------------------------------------------------

    부분배열이라는 용어를 사용하면 다차원 배열은 "배열요소가 부분배열
인 배열"이라고 생각할 수 있다. 그리고 다차원 배열 그 자체는  "모배열"
이라고 부르기로 한다. 새로 나온 용어가 아무 탈 없이 접수됐으면 아래의
글귀를 심도있게 음미하기 바란다.

---- C의 다차원 배열에 대한 근본 개념 ------------------------

 * 다차원 배열은 배열의 배열로서 구현한다.
--------------------------------------------------------------
 * 다차원 배열은 배열요소가 부분배열인 일차원 배열이다.
   n차원 배열은 배열요소가 n - 1차원 배열인 일차원 배열이다.
   따라서 이차원 배열은 배열요소가 1차원 배열인 일차원 배열이다.
--------------------------------------------------------------
 * 산술형에서 유도된(derived) 이차원 배열의 경우
   모배열의 배열요소는 1차원의 부분배열이다.
   부분배열의 배열요소는 산술형 변수이다.
--------------------------------------------------------------

    삼차원 이상의 다차원 배열의 경우에는 모배열의 부분배열 자체도  또
다른 부분배열로 구성된다. 예를 들어 삼차원 배열에서 삼차원의 모배열은
2차원의 부분배열들로 구성되며, 각각의 2차원 부분배열들은 다시 1차원의
부분배열들로 구성된다.
    이런 식으로 부분배열이 중첩되다 보면 "부분배열의 부분배열의  ....
부분배열의 부분배열"과 같이, 부분배열을 이름지을 때 그 용어가 매우 번
잡해지므로 편의상 각 부분배열의 포함 관계에 따라 아래와 같이 부르기로
약속하자. 또한 이후부터는 특별한 언급이 없는 한 "배열요소"라는 용어를
최하위 부분배열의 배열요소라는 의미로 한정하여 사용할 것이므로 용어에
착오 없기 바란다.

---------------------------------------------------------------------
[1] 모배열의 배열요소, 즉 모배열의 직속 부분배열은 최상위 부분배열(제
    1부분배열)이다.
[2] 최상위 부분배열의 배열요소(하위 부분배열)는 제2부분배열이다.
[3] 일반적으로 제n부분배열의 배열요소(하위 부분배열)는 제(n +  1)부분
    배열이다.
[4]포함 관계상 가장 하위 구조를 이루는 배열은 최하위 부분배열이며 최
    하위 부분배열은 항상 1차원 배열이다.
---------------------------------------------------------------------

  3.3 배열 연산의 허와 실

    이제부터는 C의 배열에 있어서 그 개념상 대단히 중요한 위치를  차지
하는 배열 연산과 포인터 연산의 상호 관계에 대하여 설명하겠다. 이때 배
열 연산(array operation)이란 선언문에서 배열을 정의하거나  또는  수식
중에서 첨자를 써서 배열요소를 참조하는 일(첨자 연산) 등등을 총칭한다.
또한 포인터 연산(pointer operation)은 포인터에 관계된 모든 연산을  총
칭한다.
    여기서 해야할 일은 C의 배열에 대한 파스칼이나 베이직으로부터의 선
입관이나 고정관념을 완전히 타파하는데 있다. 혹자는 배열 연산이 포인터
연산과 완전히 별개의 것으로, 혹자는 한 술 더 떠서 배열 연산과  포인터
연산이 처음부터 끝까지 완전히 호환(변환) 가능한 것으로 지대한  착각을
하는 경우가 있는데 그게 다 처음부터 포인터를 익힐 때 주마간산식의  엉
터리로 배워서 그런 것이다. 그러면 이제부터 정식으로 확실하게 익힐  수
있도록 안내하겠다.

---------------------------------------------------------------------
 * C에서 고유한 배열 연산은 오직 2가지 밖에 없다. 첫째, 그 배열의  크
   기를 결정하는 것과 둘째, 배열명을 이용하여 그 배열의 0번째  요소를
   가리키는 포인터(번지값)를 얻는 것이 전부이다.
 * 다른 모든 배열 연산은 실제로는 포인터 연산을 통하여 이루어진다. 예
   를 들어 겉으로는 배열 연산처럼 보이는 첨자 연산(subscript operatio
   n)도 사실은 포인터 연산의 다른 표현 방식에 지나지 않는다.
 * 또한 배열 전체를 통째로 함수에 전달하는 방법은 존재하지 않는다. 역
   시 포인터를 통하여 간접적으로 조작이 이루어진다(그러나 구조체를 쓰
   면 통채로 전달할 수도 있다).
---------------------------------------------------------------------

    C는 거의 대부분의 배열 연산을 포인터 연산으로 변환해서  처리한다.
따라서 거의 모든 배열 연산은 포인터만 가지고도 충분히 표현할 수 있다.
그러나 포인터로 나타낼 수 없는 배열 연산만의 고유한 영역이 방금  언급
했듯이 딱 2가지 있다.
    첫째, 배열을 정의할 때 그 배열의 크기를 결정하는 것이  포인터로는
불가능하다는 점과 둘째, 배열명으로 하여금 그 배열의 0번째 요소가 위치
하고 있는 메모리의 번지값을 가지도록 하는 것도 역시 포인터로 표현  불
가능하다는 점이다(10월호의 배열 상수 설명을 참조). 말이 거창한 것  같
아도 사실 조금만 생각해보면 당연한 얘기이다.
    그 이외의 모든 배열 연산은 내부적으로 모두 포인터 연산으로 변환하
여 처리된다. 심지어는 타언어에서 고유한 배열 연산에 속하는 첨자 연산,
즉 x[1]이나 y[2][1]과 같이 지정된 첨자에 의해 배열요소의 번지값을  알
아내어 참조하는 연산까지도 C에서는 포인터 연산으로 변환하여  처리하고
있다. 예컨데 파스칼과 같은 타언어에서는 [ ]가 첨자를 지정하는데  쓰이
는 기호에 불과하지만 C에서는 같은 기능의 [ ]가 기본 연산자(primary op
erator)라고 불리우는 연산자에 일종임에 유의하기 바란다.
    결과적으로 볼 때, C에서는 배열첨자의 사용이  어디까지나  선택적이
다. 배열첨자를 사용할 것이냐 아니면 그와 동일한 포인터 수식으로  표현
할 것이냐 하는 문제는 전적으로 프로그래머의 기호, 관습 또는 수식 표현
상의 간편성 여부에 달려있다.

    C에서는 첨자 연산이 곧 포인터 연산이라는 증거는 아래 <예제 1>에서
찾아 볼 수 있다. 파스칼이나 베이직의 고정관념으로는  상상을  불허하는
첨자 사용예가 <예제 1>에 출현한다.


<예제 1> 첨자 연산은 포인터 연산이다.
---------------------------------------------------------------------
01: void main(void)
02: {               +----------------------- 배열 x를 초기화했다.
03:     int i, x[3] = {100, 200, 300};
04:
05:     for (i = 0; i < 3; i++)
06:         printf("%d ", x[i]);
07:     for (i = 0; i < 3; i++)
08:         printf("%d ", i[x]); --------+----- 이 두 행에 주목할 것
09:     for (i = 1; i <= 3; i++)         |      절대 에러가 아님
10:         printf("%d ", (i - 1)[x]); --+
11:
12:     printf("\n");
13: }
---------------------------------------------------------------------
실행 결과

100 200 300 100 200 300 100 200 300
---------------------------------------------------------------------

    <예제 1>의 8행과 10행에 출현한 수식에서, 일반적인 상식으로는 배열
명을 두어야 한다고 생각되는 자리에 의외로 정수 변수(8행)는 물론  괄호
를 동반한 임의의 정수 수식(10행)을 놓을 수도 있다는 것은 놀라운  사실
이 아닐 수 없다. 물론 그 대신에 [ ] 안에다가 배열명을  놓기는  했지만
말이다.
    이렇게 생소한 첨자 사용법도 사실은 지난 10월호에서 이미 예고를 한
것이다. 10월호의 "배열 참조에 관한 정의"를 주의깊게 읽어보면 <예제 1>
의 수식이 절대로 그 정의에 위배되지 않는다는 사실을 알아챌 수 있을 것
이다. 지금 당장 진짜 그런지 확인해 보시라.
    어쨌든 i[x]와 같은 수식은 C의 첨자 연산이 배열 연산에 속하는 것이
아니라 포인터 연산에 속한다는 결정적인 증거이다. 파스칼이나  베이직에
서는 첨자 연산이 고유한 배열 연산에 속하기 때문에 i[x],  i++[x]  같은
수식은 근본적으로 표현 불가능할 수 밖에 없다. 참고로 C에서는 i++[x]와
같은 별스런 수식도 정의에 의하여 x[i++]와 완전히 동일한 수식이다.

  3.4 포인터 생성에 관한 정의와 부분배열명의 의미

    배열명(모배열명)이 수식 내에서 그 배열의 0번째 요소를 가리키는 포
인터로 쓰인다는 사실은 앞부분과 10월호에서 이미 언급했다. 여기서는 모
배열명은 물론 부분배열명까지도 포함하여, 일반적으로  임의의  배열명이
수식 내에 참조될 때 가지는 의미에 대한 정의를 설명하겠다.

---- 포인터 생성(pointer generation)에 관한 정의 I ------------------

    만약 주어진 수식이나 부수식의 데이터형이 임의의 T형 데이터에서 유
도된 "T형 배열"이라면, 그 수식의 값은 그 배열 내의 첫번째  대상체(0번
째 배열요소)를 가리키는 포인터(번지)가 된다. 그리고 그 수식의  데이터
형은 "T형을 가리키는 포인터"로 변경된다.

    If the type of an expression or subexpression is "array of T", fo
r some type T, then the value of the expression is a pointer to the f
irst object in the array, and the type of the expression is altered t
o "pointer to T".
---------------------------------------------------------------------

    수식이나 부수식은 배열명 단독으로 구성될 수도 있다. 그리고 변경이
라는 말은 개념적인 변환을 의미한다. 즉 실제로 변환을 위해 기계어 코드
가 만들어지지는 않는다. 위의 정의 I을 배열명에 적용하여 해석을 유도한
다면 한 마디로 다음과 같다. 모배열이나 부분배열을 막론하고,

    "수식 내의 배열명은 그 배열의 0번째 요소를 가리키는 포인터이다."

    위의 문장은 포인터 생성에 관한 정의에서 유도해낸 결론이다. 그  유
도 과정은 잠시 후에 밝힐 것이다. 그러면 부분배열명은 실제로 어떻게 나
타내는지 알아보자. 예컨데 이차원 배열(배열의 배열) y가 정의되어  있다
고 할 때 y[0]는 모배열 y의 배열요소인 어떤 부분배열을  의미(대표)하게
된다. 즉 y[0]는 모배열 y의 0번째 부분배열명이 된다.  이를  일반적으로
표현하면 아래와 같다.

-----------------------------------------------------------------
 다차원 배열 array[size1][size2]......[sizen]이 정의되어 있을 때
-----------------------------------------------------------------
 array[i1]는 최상위 부분배열명이다.
 array[i1][i2]는 제2부분배열명이다.
 ......
 array[i1][i2]......[in-1]은 최하위 부분배열명이다.
 array[i1][i2]......[in-1][in]은 배열요소이다.
-----------------------------------------------------------------

[그림 6] 부분배열의 계층도
---------------------------------------------------------------------

3차원배열 -------->              모배열 z
              +---------------------------------------------+
              |                                             |
2차원배열 ---> 부분배열 z[0]   부분배열 z[1]   부분배열 z[2]
              +-------------+ +-------------+ +-------------+
              |             | |             | |             |
             +---+---+---+---+---+---+---+---+---+---+---+---+
             | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10| 11| 12|
             +---+---+---+---+---+---+---+---+---+---+---+---+
              |     | |     | |     | |     | |     | |     |
              +-----+ +-----+ +-----+ +-----+ +-----+ +-----+
1차원배열 --> z[0][0] z[0][1] z[1][0] z[1][1] z[2][0] z[2][1]

---------------------------------------------------------------------

<예제 2> 수식 내에서 쓰인 부분배열명의 의미
---------------------------------------------------------------------
#define printarrayname(expr) printf("%15s == %p\n\n", #expr, expr)
#define printarraysize(expr) printf("%15s == %d\n", #expr, expr)

void main(void)
{
    int z[3][2][2] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};

    printarrayname(z);

    printarrayname(z[0]);
    printarrayname(z[1]);
    printarrayname(z[2]);

    printarrayname(z[0][0]);
    printarrayname(z[0][1]);
    printarrayname(z[1][0]);
    printarrayname(z[1][1]);
    printarrayname(z[2][0]);
    printarrayname(z[2][1]);

    printarraysize(sizeof(z));
    printarraysize(sizeof(z[0]));
    printarraysize(sizeof(z[1]));
    printarraysize(sizeof(z[2]));
    printarraysize(sizeof(z[0][0]));
    printarraysize(sizeof(z[0][1]));
    printarraysize(sizeof(z[1][0]));
    printarraysize(sizeof(z[1][1]));
    printarraysize(sizeof(z[2][0]));
    printarraysize(sizeof(z[2][1]));
}
---------------------------------------------------------------------
실행 결과(터보 C 2.0에서 실행)
포인터값(번지값)은 상황에 따라 달라지므로 여기서는 그 상대적인 값에만
주목하도록 한다.

              z == FFC8        ---> z는 3x2x2 크기의 정수 배열

           z[0] == FFC8 -+
                         +- +8 ---> z[0]는 2x2 크기의 정수 배열
           z[1] == FFD0 -+
                         +- +8  ==  2 * 2 * sizeof(int)
           z[2] == FFD8 -+

        z[0][0] == FFC8 -+
                         +- +4 ---> z[0][0]는 배열크기 2의 정수 배열
        z[0][1] == FFCC -+
                         +- +4  ==  2 * sizeof(int)
        z[1][0] == FFD0 -+
                         +- +4
        z[1][1] == FFD4 -+
                         +- +4
        z[2][0] == FFD8 -+
                         +- +4
        z[2][1] == FFDC -+


      sizeof(z) == 24  ← 3 * 2 * 2 * sizeof(int)
   sizeof(z[0]) == 8
   sizeof(z[1]) == 8   ← 2 * 2 * sizeof(int)
   sizeof(z[2]) == 8
sizeof(z[0][0]) == 4   ← 2 * sizeof(int)
sizeof(z[0][1]) == 4
sizeof(z[1][0]) == 4
sizeof(z[1][1]) == 4
sizeof(z[2][0]) == 4
sizeof(z[2][1]) == 4
---------------------------------------------------------------------

    포인터 생성에 관한 정의 I을 주의깊게 살펴보면 <예제 2>의 실행  결
과에 약간의 의문을 가질 수 있다. 그 의문이란 sizeof 연산자에 관한  것
이다. 만약 정의 I을 sizeof 수식에도 마찬가지로 적용한다면 sizeof(z)가
24라는 값을 가질 수는 없다. 정의 I에 따르면 z가 포인터로 자동  변환된
다고 했으므로 sizeof(z)의 결과는 마땅히 포인터의 바이트 크기인 2가 되
어야 하기 때문이다. 이 문제점으로 인해 또다른 보충 정의가 필요하게 된
다.
    아래의 포인터 생성에 관한 정의 II가 바로 그것이다. 정의 II에 따르
면 sizeof 연산자의 피연산자인 배열명 z에는 정의 I에서와  같은  변환이
일어나지 않으므로, sizeof(z)에서 z의 데이터형이 포인터형으로 변환되는
것이 아니라 배열형을 그대로 유지하게 된다. 따라서 결과는 포인터  수식
의 바이트 크기인 2가 아닌 배열 z의 바이트 크기인 24가 나오는 것이다.

---- 포인터 생성(pointer generation)에 관한 정의 II -----------------

    만약 사용하는 수식이 단항 & 연산자, ++, --, 또는 sizeof  연산자의
피연산자이거나 대입 연산자 또는 . 연산자의 좌측 피연산자라면 정의 I에
서와 같은 변환이 일어나지 않는다. 그리고 정의 I에서와 같은 변환을  일
단 거친 수식은 더 이상 좌변값(lvalue)이 아니다. 즉 포인터 수식이다.

    This conversion does not take place if the expression is the oper
and of the unary & operator, or of ++, --, sizeof, or as the left ope
rand of an assignment operator or the . operator. An expression  that
has suffered one of these conversions is not an lvalue.
---------------------------------------------------------------------

  3.5 수식 *(*(y + i) + j)의 분석

    우선 지금까지 간단히 개념만 소개한 대상체(object)와  좌변값(lvalu
e)에 대한 아래의 완전한 정의를 기억해 두기 바란다. 좌변값을 예로 들자
면 임의의 변수나 배열요소 등을 꼽을 수 있다. 좌변값은 다시 말해서  값
을 대입할 수 있는 어떤 것이라고 보면 된다.

------------------------------------------------------------
 대상체란 기억 장소 내에 이름이 붙여진 어느 영역을 일컫는다.
 An object is a named region of storage
 좌변값이란 대상체를 참조하는 임의의 수식이다.
 An lvalue is an expression referring to an object
------------------------------------------------------------

    대상체라는 용어를 사용하면 간접지정 연산자 *는 피연산자인  포인터
가 가리키고 있는 대상체를 구하는 연산자라고 간단하게 정의할 수  있다.
단항 * 연산자의 완전한 정의는 아래와 같다. 이 정의에서  구조체,  함수
등등을 가리키는 포인터라는 대목은 나중에 설명할 테니 지금은 그냥 무시
하기 바란다. 아래에서 단항 * 연산식이 좌변값이라는 것은 변수처럼 그곳
에 값을 대입할 수도 있다는 뜻이다.

---- 간접지정 연산자 *의 정의 ---------------------------------------

    단항 * 연산자는 간접지정을 나타내며 피연산자가 가리키고 있는 대상
체나 함수를 구한다. 만약 피연산자가 산술형, 구조체형, 공용체형,  포인
터형(배열명 포함) 등을 가리키는 포인터라면, 즉 피연산자가  함수형이나
void형이 아닌 데이터형이라면 * 연산자의 결과는 좌변값이 된다. 다시 말
해서 만약 수식의 데이터형이 "T를 가리키는 포인터"라면 결과의 데이터형
은 T이다.

    The unary * operator denotes indirection, and returns the  object
or function to which its operand pointes. It is an lvalue if the oper
and is a pointer to an object of arithmetic, struct, union, or pointe
r type. If the type of the expression is "pointer to T", the type  of
the result is T.
---------------------------------------------------------------------

<예제 3> 단항 * 연산자의 의미
---------------------------------------------------------------------
void main(void)
{
    int i = 1, j = 0, y[2][2] = {100, 200, 300, 400};

    printf("%d %d %d\n", *(*(y + i) + j), (*(y + i))[j], *(y[i]  +  j
));
    printf("%d %d %d\n", y[i][j], i[y][j], j[i[y]]);
    printf("%d %d %d\n", y[1][0], 1[y][0], 0[1[y]]);
}                                   |       | 배열 참조에 관한 정의에
                                    +-------+ 따르면 적법한 수식임
---------------------------------------------------------------------
실행 결과

300 300 300
300 300 300
300 300 300
300 300 300
---------------------------------------------------------------------

    배열 y에서 연산순위를 명시하기 위해 배열요소를 나타내는 y[i][j]라
는 수식에 괄호를 사용하면 ((y)[i])[j]와 같아진다. 그리고 나서 지난 10
월호의 배열 참조에 관한 정의에 따라 첨자 수식을 포인터 수식으로  변환
하면 *(*(y + i) + j)가 된다. 여기서 주목할 것은 수식 *(*(y + i) +  j)
에서 각각의 단항 * 연산 결과가 서로 다르다는 점이다. 이 수식을 완전히
분해하여 설명하면 다음와 같다. 그런데 포인터 생성에 관한 정의 I과  단
항 * 연산자의 완전한 정의를 이미 밝혔으므로 그림을 통한 친절한 해설은
생략하겠다.

---------------------------------------------------------------------
[1] y + i

    y + i는 모배열 y의 i번째 부분배열의 위치를 가리키는 포인터 수식이
다. 포인터 수식이므로 우리가 사용하는 소형 메모리 모델에서 sizeof(y +
i)의 결과는 2이다.

[2] *(y + i)

    단항 * 연산자는 y + i가 가리키는 대상체인 i번째  부분배열  전체를
구한다. 따라서 수식 sizeof(*(y + i))는 실제 부분배열의 전체 바이트 크
기인 2 * sizeof(int) == 4의 값을 가진다.
    한편 y + i가 가리키는 대상체가 배열이므로 *(y + i)는 배열형이  된
다. 그런데 대부분의 경우 포인터 생성에 관한 정의 I에 따라 원래는 배열
형인 *(y + i)의 데이터형이 y의 i번째 부분배열의 0번째 배열요소를 가리
키는 포인터로 자동 변환된다. 쉽게 말해서 대부분의 경우에 *(y  +  i)는
배열요소 y[i][0]를 가리키는 포인터라는 뜻이다. 이때 "대부분의 경우"라
고 제한을 두는 이유는 포인터 생성에 관한 정의 II가 있기 때문이다.
    우리는 배열 참조에 관한 정의에 따라 *(y + i)가 y[i]와 완전히 동일
하다는 사실을 알고 있다. 그런데 잠시 전에 y[i]는 부분배열명이라고  언
급했다. 따라서 이 두 가지 사실을 서로 연관지으면 "배열명은 그  배열의
0번째 요소를 가리키는 포인터이다"라는 결론을 어렵지 않게 유도할 수 있
다.
    단, sizeof, ++, -- 같은 연산자의 피연산자로서의 *(y + i)는 포인터
생성에 관한 정의 II에 의해 포인터로 자동 변환이 되지 않는다는 것을 이
미 설명한 바 있다.

[3] *(y + i) + j

    이 수식은 y[i] + j와 정의에 의해 완전히 동일하며, i번째  부분배열
의 j번째 배열요소를 가리키는 포인터 수식이다. 간단히 말해서  배열요소
y[i][j]를 가리키는 포인터 수식 &y[i][j]와 동등하다는  뜻이다.  포인터
수식이므로 역시 sizeof 연산의 결과는 2이다.

[4] *(*(y + i) + j)

    y[i][j]를 가리키는 포인터에 단항 * 연산자를 사용했으므로 결과는 i
nt형 배열요소 y[i][j] 자체가 된다. 실제로 배열 참조에 관한 정의에  따
라서 y[i][j]와 완전히 동일하다. sizeof 연산식의 결과는 int형의 바이트
크기인 2가 된다.
---------------------------------------------------------------------

    이상에서 포인터 수식 *(*(y + i) + j)를 완전 해부했다. 그러면 진짜
그런가 알아보기 위하여 다음의 <예제 4>를 직접 실행해보기 바란다.  <예
제 4>에서 한 가지 짚고 넘어가야 할 사항은 수식 *(y + i)와 *(y + i)  +
0의 차이점이다. 도대체 무슨 차이가 있느냐고? 실행해 보면  알게  된다.
이 차이점을 알아낼 수만 있다면 포인터 생성에 관한 정의 I, II를 완전히
정복했다고 봐도 틀림이 없으므로 한 번 곰곰히 생각해 보기  바란다.  힌
트: sizeof, ++ 등등의 연산식에서만 차이가 난다.

<예제 4> 수식 *(*(y + i) + j)의 사용 예
---------------------------------------------------------------------
#define printpointer(expr) printf("%30s == %p\n", #expr, expr)
#define printsize(expr) printf("%30s == %d\n", #expr, expr)

void main(void)
{
    int i, j, y[3][2];

    i = j = 1;
    y[i][j] = 100;

    printpointer(y + i);
    printsize(sizeof(y + i));

    printpointer(*(y + i));
    printsize(sizeof(*(y + i)));
    printsize(sizeof(y[i]));

    printpointer(*(y + i) + 0);
    printsize(sizeof(*(y + i) + 0));

    printpointer(*(y + i) + j);
    printsize(sizeof(*(y + i) + j));

    printsize(*(*(y + i) + j));
    printsize(sizeof(*(*(y + i) + j)));
    printsize(sizeof(y[i][j]));
}
---------------------------------------------------------------------
실행 결과(터보 C 2.0에서 실행)
각 번지의 상대적인 값에만 주목하도록 한다.  절대적인 값은 전혀 의미가
없다.

                         y + i == FFCE
                 sizeof(y + i) == 2
                      *(y + i) == FFCE
              sizeof(*(y + i)) == 4   --+
                  sizeof(y[i]) == 4     +----- 서로 결과가 다르다.
                  *(y + i) + 0 == FFCE  |
          sizeof(*(y + i) + 0) == 2   --+
                  *(y + i) + j == FFD0
          sizeof(*(y + i) + j) == 2
               *(*(y + i) + j) == 100
       sizeof(*(*(y + i) + j)) == 2
               sizeof(y[i][j]) == 2
---------------------------------------------------------------------


---------------------------------------------------------------------
  4  다차원 배열 포인터
---------------------------------------------------------------------

  4.1 다차원 배열 포인터의 의미와 용도

    "배열 포인터(array pointer)"라는 말은 "배열을 가리키는 포인터(poi
nter to array)"라는 뜻이다. 마찬가지로 "다차원 배열 포인터"라는  말은
"다차원 배열을 가리키는 포인터(pointer to multi-dimensional array)"라
는 뜻이다.
    일차원 배열 포인터는 지난 10월호에서 충분히 다루어 보았다. 여기서
는 다차원 배열 포인터를 다루는 방법에 대하여 알아보겠다. 이에 앞서 다
차원 배열 포인터를 사용하는 이유를 4가지 정도만 들어보자. 다음의  4가
지 이유 중에서 [3]번이 가장 유력한 이유이다.

    +---- 다차원 배열을 포인터로 다루는 이유 4가지 --------+
    |                                                      |
    | [1] ++, -- 등의 연산자를 사용하기 위해               |
    | [2] 연산 속도가 빠르며 기계어 코드가 간결하기 때문에 |
    | [3] 매개변수가 다차원 배열인 함수를 작성하기 위해    |
    | [4] 다차원 배열을 일차원 배열로 다루기 위해          |
    +------------------------------------------------------+

    이 중에서 [3]번, [4]번 항목은 지면이 모자라는 관계로 다음  12월로
설명을 미루기로 한다.

    4.2 이차원 배열 포인터 py를 정의하는 방법과 주의할 점

    우선 이차원 배열 포인터(pointer to two-dimensional array)는  아래
와 같이 정의한다. 이때 배열요소형은 기억부류지정자를 포함할  수  있으
며, 열의 갯수는 반드시 상수 수식이어야 한다. 그리고 괄호( )를 생략하
면 구두점 [ ]와 *의 우선순위로 인해 전혀 엉뚱한 포인터  배열(12월호에
설명할 예정)을 정의하게 되므로 주의하여야 한다.

    +------------------------------------+
    | 배열요소형 (*포인터명)[열의 갯수]; |
    +------------------------------------+

    가령 int형 이차원 배열 y를 포인터로 다루기 위하여 y를 가리키는 포
인터 py를 정의하고자 한다면 아래와 같이 한다. 만약 py가 함수의 형식매
개변수라면 가능한 방법이 한 가지 더 있기는 하지만  이번에는  언급하지
않는다.

   int (*py)[2];

    위와 같이 하면 y를 가리킬 수 있는 이차원 배열 포인터 py가  정의된
다. 이때 열의 갯수 2를 생략할 수는 없다. 열의 갯수를 생략해 버리면 한
행이 과연 몇 열로 구성되어 있는지 컴파일러가 알 방도가 전혀  없으므로
포인터로 이차원 배열을 조작할 수가 없게 된다.
    그러나 이것은 부차적인 이유이고 열의 갯수를 생략할 수  없는  근본
이유는 아래와 같다.

---------------------------------------------------------------------
 포인터 변수 py를 정의할 때 py가 가리키는 대상체의 크기를 어떠한  방
 법으로든 반드시 명시해주어야 한다.
---------------------------------------------------------------------

    포인터 변수를 선언(!= 정의)할 때에도 이와 마찬가지이다. 만약 대상
체의 크기를 알려주지 않으면 포인터에 단항 * 연산자를 써서 그 대상체를
참조할 때 문제가 발생한다. 예를 들어 *py라는 수식이 있을 때 단항 * 연
산자에 의해 py가 현재 가리키고 있는 번지에서 과연 몇 바이트만큼을  읽
어내야 하는지 컴파일러가 알 방도가 없다.
    한편 py가 가리키는 것은 이차원 배열 y이다. 그런데 py의 대상체가 y
전체라고 착각하면 이건 정말로 곤란하다. py가 가리키는 것은 배열 y이지
만 py의 대상체는 배열 y 전체가 아니라 *py이다. 이때 *py는 py가 가리키
는 번지에서부터 읽어내야 할 메모리상의 영역이므로 y의  부분배열  중의
하나가 된다. 따라서 py의 대상체는 배열 y 전체가 아니라  y의  부분배열
중의 하나, 예컨대 y[0]같은 것임을 알 수 있다.

    int x[3], *px;
    px = x;  ← px를 초기화한다.

    지금 한참 헷갈리고 있는 사람을 위해 위의 일차원 배열 포인터  px를
예로 들어보자. px는 일차원 배열 x를 가리킨다고 말은 하지만 실제로  px
의 대상체는 x 전체가 아니라 x의 배열요소임을 익히 알고 있을 줄로 믿는
다. 따라서 대상체를 참조하는 *px라는 수식은 x 전체를 읽어내지 않고  x
의 배열요소, 예컨데 x[0]를 읽어내게 된다.
    다시 본론으로 되돌아가서 py의 대상체(즉 *py)는  y의  부분배열(1차
원)이므로 대상체의 크기를 명시한다는 것은 곧 그  부분배열의  크기(y의
제2첨자크기)를 명시하는 것을 의미한다. 따라서 py의 열의 갯수 2는 절대
로 생략할 수 없다.
    이러한 이유 때문에 포인터 py를 정의할 때 열의 갯수를 생략해  버리
면 컴파일러가 "Size of structure or array not known"이라는 에러를  내
므로 항상 주의하기 바란다.

[그림 7]  py를 정의한 직후의 메모리 상태
---------------------------------------------------------------------

    +--------- 아직 아무것도 가리키지 않고 있다.
    |
    |
포인터 py          배열 y
+-------+          +-------+-------+-------+-------+-------+-------+
|       |          |       |       |       |       |       |       |
+-------+          +-------+-------+-------+-------+-------+-------+
    |                [0][0]  [0][1]  [1][0]  [1][1]  [2][0]  [2][1]
    |
    |
    +--------- 아직 초기화를 하지 않았으므로 자동 변수일 경우에는
               쓰레기(garbage)가 그대로 잔존한다.

---------------------------------------------------------------------

  4.3 포인터 py의 초기화 방법과 주의할 점

    앞에서는 py를 정의하는 방법만 설명했다. 그렇게 정의된 py를 실제로
사용하려면 먼저 py를 초기화하는 작업이 필요하다. 여기서 말하는 초기화
라는 말은 선언문에서의 초기화가 아니라 기억장소 내에 잔존하는  쓰레기
(garbage)값을 치우는 작업을 의미한다. py를 초기화하는  방법은  아래와
같이 배열명 y를 py에 직접 대입하는 것이다.

    py = y;

    위의 대입식이 적법(valid)한 이유는 이렇다. 먼저 배열명 y는 포인터
생성에 관한 정의 I에 의해 "크기가 2인 1차원 부분배열 y[0]"를 가리키는
포인터로 자동 변환된다. 여기서 y는 대입 연산자 =의 좌변이 아니라 우변
에 위치하고 있으므로 포인터 생성에 관한 정의 II에 전혀 저촉됨이  없이
y는 포인터로 자동 변환된다. 그러나 아래의 문구를 유념해야 한다.

---------------------------------------------------------------------
 대입식에서 원치 않는 자동 변환이 발생하지 않도록 하려면 = 양변의 데
 이터형이 항상 일치해야 한다. 따라서 어떤 포인터 변수 pa에 어떤 포인
 터 수식을 대입하고자 한다면, 대입하려는 우변 수식의 데이터형과 좌변
 의 포인터 변수 pa의 데이터형이 서로 완전히 일치해야 한다.
---------------------------------------------------------------------

    다시 말해서 좌변 포인터 pa의 대상체와 우변 포인터 수식의 대상체가
완전히 동일한 데이터형이어야 한다는 뜻이다. 이와 같은 주의 사항을  위
반하면 심각한 논리 에러가 발생될지도 모른다는 사전 경고로서  컴파일할
때 "Suspicious pointer conversion"이라는 경고 메시지를 받게 된다.  아
마도 포인터를 주의깊게 사용하지 않는 독자는 뭔지도 모르고 심심치 않게
이런 경고를 자주 받았을 것이다.
    만약에 좌변의 포인터 pa의 대상체가 어떤 부분배열이라면, pa의 대상
체인그 부분배열의 차원 및 각 첨자크기가 우변의 포인터 수식의  그것과
서로 완전히 일치해야만 한다.
    이제 다시 본론으로 돌아와서, py의 대상체(== *py)는 그 자신의 정의
에 따라 크기가 2인 1차원 배열이다. 포인터로 변환된 y가 가리키는  대상
체(== *y) 역시 크기가 2인 1차원 배열이다. 따라서 py = y는 적법한 수식
이 된다.
    만약 아래와 같이 일차원 배열 포인터인 px에 y를 대입하려  시도한다
면 "Suspicious pointer conversion" 경고를 틀림없이 받게 된다.

     px = y; --+- 경고 발생
               |
     py = x; --+

[그림 8]  py를 초기화한 직후의 메모리 상태 개념도
---------------------------------------------------------------------

포인터 py          배열 y
+-------+         +-------+-------+-------+-------+-------+-------+
|   o --+-------->|       |       |       |       |       |       |
+-------+         +-------+-------+-------+-------+-------+-------+
y의 선두번지값을    [0][0]  [0][1]  [1][0]  [1][1]  [2][0]  [2][1]
가진다.

---------------------------------------------------------------------

  4.4 포인터 py에 의한 배열 참조

    이차원 배열 포인터 py를 일단 정의하고 초기화한 다음에는 py를 그저
y 쓰듯이 마음대로 사용할 수 있다. 즉 py를 가지고 배열 y를  자유자재로
참조할 수가 있다는 말이다.
    예를 들어 py[1][1]은 배열요소 y[1][1]과 완전히 동등(equivalent)하
다. 단지 차이점이 있다면 py[1][1]은 포인터 변수 py를 이용한 배열 참조
이고, y[1][1]은 포인터 상수 y에 의한 배열 참조라는 것 뿐이다.
    마찬가지로 py[1]도 y[1]과 동등하며 둘 다 y의 1번째 부분배열을  의
미한다. 또한 py[1]의 원래 데이터형은 배열형이다. 하지만 py[1]이  수식
내에 쓰인다면 y[1]과 마찬가지로 대부분의 경우에 그 데이터형이  부분배
열 y[1]을 가리키는 포인터로 자동 변환된다.

[그림 9]  py를 이용하여 배열 y를 참조할 때의 상황 개념도
---------------------------------------------------------------------

                   배열 y
                 +-------+-------+-------+-------+-------+-------+
                 |       |       |       |       |       |       |
                 +-------+-------+-------+-------+-------+-------+
                  y[0][0] y[0][1] y[1][0] y[1][1] y[2][0] y[2][1]

                     |       |       |       |       |       |
 포인터 py           |       |       |       |       |       |
 +-------+           |       |       |       |       |       |
 |   o --+-----------+-------+-------+-------+-------+-------+
 +-------+     py[0][0] py[0][1] py[1][0] py[1][1] py[2][0] py[2][1]
 py = y에
의해 초기화됨

---------------------------------------------------------------------

    지금까지 이차원 배열 포인터 py의 모든 것에 대해  설명했는데  사실
말이 조금 어려울 뿐이지 실제로 사용해보면 배열 포인터라는 것도 별  것
이 아님을 알 수 있다. <예제 5>를 봐도 그렇다. 괜히 노파심에 주의 사항
을 밑도 끝도 없이 너저분하게 늘어 놔서 어렵게 보이는 것이지  포인터를
쓰기 위하여 실제로 해야 할 일은 지극히 단순하고 간단하다.
    배열 포인터를 쓰고자 할 때 실제로 해야 할 일은 간단히 3단계로  압
축할 수 있다. 배열 포인터를 쓰기 위한 3단계 방법은 보는 사람의 시각에
따라 그 방법을 아는 사람에게는 지극히 단순해 보일 것이고 그 방법을 모
르는 사람에게는 상상을 초월할 만큼 어렵게 보일 수도 있는 것이다. 독자
는 과연 전자와 후자 중 어느 쪽에 속하는지 궁금하다. 하여간에 그 3단계
는 "정의 -> 초기화 -> 대상체 참조"의 순서로 이루어진다.

[표 1] 배열 포인터의 사용법 3단계
----------------------------------------
 포인터 사용의 3단계
----------------------------------------
 제1단계 배열 포인터를 정의한다.
 제2단계 배열 포인터를 초기화한다.
 제3단계 배열 포인터로 배열을 참조한다.
----------------------------------------

<예제 5>  배열 포인터 py의 사용예
---------------------------------------------------------------------
#define printexprp(expr) printf(#expr " == %p\n", expr)
#define printexpri(expr) printf(#expr " == %d\n", expr)

void main(void)
{
    int y[][2] = {{100, 200}, {300, 400}, {500, 600}};
    int (*py)[2];

    py = y;

    printexprp(y[1]);
    printexprp(py[1]);
    printexpri(sizeof(y[0]));
    printexpri(sizeof(py[0]));
    printexpri(y[0][0]);
    printexpri(py[0][0]);
    printexpri(y[2][1]);
    printexpri(py[2][1]);
}
---------------------------------------------------------------------
실행 결과

y[1] == FFDC
py[1] == FFDC
sizeof(y[0]) == 4
sizeof(py[0]) == 4
y[0][0] == 100
py[0][0] == 100
y[2][1] == 600
py[2][1] == 600
---------------------------------------------------------------------

    위의 <예제 5>에 조금이라도 의문나는 사항이 있으면 "배열 참조에 관
한 정의", "포인터 생성에 관한 정의 I", "포인터 생성에 관한 정의  II",
"간접지정 연산자 *의 정의" 등 4가지 정의를 자라같이 끈질기게 물고  늘
어지면 조만간 이해가 가리라 본다.
    끝으로 지금까지 예제에서 매크로 함수를 정의하면서 전처리기 연산자
#을 아무 언급없이 써왔는데, 이 특수한 연산자의 쓰임새는 이 글  첫머리
에서 소개한 정복 터보 C라는 책의 9.3.4절에 자세하게 설명되어 있다. 그
밖에 터보 C User's Guide 매뉴얼 원서의 230쪽(터보 C 1.5)  또는  334쪽
(터보 C 2.0)을 참고해도 된다.


---------------------------------------------------------------------
  5  다음에는
---------------------------------------------------------------------

    지금까지 사흘에(내지는 한 달에) 걸쳐 실매개변수를 변경하는 함수를
작성하는 방법과 다차원 배열 포인터에 관해 익혔다. 이번 달의  내용에는
생소한 개념을 가지는 이론적인 것들이 많아서 이해하는데 다소 시간이 걸
리지 않을까 우려된다. 그러나 이번 달의 내용은 배열과 포인터의  관계에
있어서 가장 중요한 핵심 사항이므로 배열을 포인터로 다루고 싶은 사람은
어떻게 해서든지 이 글을 소화해 내야만 할 것이다. 이 글을 소화해  내지
못하면 다음 달의 글도 역시 이해하지 못하게 된다.
    그리고 지면 관계상 배열의 초기화 방법이나 단항 & 연산자에 대한 보
다 자세한 설명 등등, 다차원 배열에 관계된 몇 가지 사항을 다루지  못한
것이 내심 아쉬울 따름이다. 이 사항들은 이 글 첫머리에서  소개한  정복
터보 C라는 책의 10장과 11장에 상세히 설명되어 있으므로 금전적, 시간적
여유가 있는 사람은 그 책을 참고하기 바란다.
    다음에는 다차원 배열 포인터의 응용으로서 매개변수가 다차원 배열인
함수를 작성하는 방법과 (지면 사정이 허락되면) 다차원 배열을 일차원 배
열로 다루는 방법을 알아본 뒤, 곧이어 포인터 배열에 관해 집중적으로 논
할 예정이다. 포인터 배열은 C에서 문자열 배열을 구현하는데 필수적인 것
으로서 C에서 문자열 배열을 제대로 만들어 써보지 못해 걱정했던  독자들
은 기대해도 좋을성 싶다.


---------------------------------------------------------------------
  부록  덤으로
---------------------------------------------------------------------

    여지껏 해온 것 같이 이달에도 덤으로 예제 하나 돌려보기로 한다. 이
번 예제는 볼만한 그래픽 예제가 아니고 들을만한 사운드 예제이다. 이 예
제는 볼랜드에서 제공하는 파스칼 데모 프로그램 중의 하나인 soundex.pas
에서 일부분을 발췌하여 C로 번역한 다음 적당히 손 좀 본 것이다. 내용에
는 신경쓰지 말고 그저 실행시켜보는 재미에 만족하기 바란다.
    우선 예제를 woods.c라는 화일명으로 입력부터 한다. 다 입력하고  디
스크에 세이브한 뒤 <F9>키를 눌러 컴파일◎링크가 무사히 끝나는가  확인
하고 터보 C 1.5에서는 <Alt-R>키, 터보 C 2.0에서는 <Ctrl-F9>키를  눌러
서 예제를 실행시킨다. 그러면 뭔 소리가 날 것이다. 귀 기울여 보시라.

<덤 예제> 숲속에서...
---------------------------------------------------------------------
/* File: WOODS.C - Sound example */

#include <conio.h>
#include <dos.h>
#include <stdlib.h>
#include <time.h>

typedef unsigned char far *display_buffer;
typedef unsigned char byte;
typedef unsigned word;

enum {BIRD1 = 1, BIRD2, BIRD3, BIRD4};

void who_is_singing(int bird);
void singing_bird(int bird, word duration, int pitch, int note);

#define _calcaddr(x, y) \
        (display_buffer)MK_FP(_displaybufferbase, \
         160 * ((y) - 1) + 2 * ((x) - 1))
#define _outch(addr, c, attr) \
        (*(word far *)(addr) = (byte)(c) | (byte)(attr) << 8)

word _displaybufferbase;

void main(void)
{
    int bird;
    struct text_info info;

    gettextinfo(&info);
    _displaybufferbase = (info.currmode == C80) ? 0xb800 : 0xb000;

    cprintf("Press any key to stop singing\r\n");
    randomize();
    do {
        bird = random(4) + 1;
        who_is_singing(bird);
        singing_bird(bird, random(2000) + 300,
                     random(4000) + 200, random(2));
        delay(random(500) + 50);
    } while (!kbhit());
    getch(); /* clear key input buffer */
    nosound();
    putch('\r');
    clreol();
}

void who_is_singing(int bird)
{
    static char *order[] = {
   "", "pretty", "small", "charming", "lovely"
    };

    putch('\r');
    clreol();
    cprintf("A %s bird is now singing...", order[bird]);
}

void song(int note)
{
    _outch(_calcaddr(wherex(), wherey()),
           (note == 0) ? '\x0e' : '\x0d', 0x0f);
    gotoxy(wherex() + 1, wherey());
}

void singing_bird(int bird, word duration, int pitch, int note)
{
    int i = 1, j, k;

    switch (bird) {
    case BIRD1: for (; i < duration; i++) {
                    sound(pitch + i);
                    if (i % 50 == 0) song(note);
                }
                break;
    case BIRD2: for (; i < duration; i++) {
                    sound(pitch + i);
                    if (i % 50 == 0) song(note);
                }
                nosound();
                delay(100);
                for (j = i + i / 10; i > j; i--) {
                    sound(pitch + i);
                    if (i % 50 == 0) song(note);
                }
                break;
    case BIRD3: for (k = 1; k < random(20) + 10; k++) {
                    sound(pitch);
                    delay(30);
                    song(note);
                    sound(pitch + pitch / 10);
                    delay(30);
                }
                break;
    case BIRD4: k = pitch + pitch / 10;
                for (i = random(5) + 10; i > 1; i--) {
                    for (j = pitch; j < k; j += 10) {
                        sound(j);
                        delay(6);
                    }
                    nosound();
                    song(note);
                    delay(40);
                }
                break;
    } /* switch */
    nosound();
}
---------------------------------------------------------------------
