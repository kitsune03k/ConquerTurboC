 임인건   (turbo28 )
[강좌] C포인터2: 포인터 연산의 정복

작성 연월일: 1989.8.27
마이크로소프트웨어 게재: 1989.10
HWP/TXT 변환: 1993.3.5

                         >>> 정복 터보 C <<<

            제2회  포인터 연산(pointer operation)의 정복

                   글/임인건 (서울대 기계공학과3)


---------------------------------------------------------------------
  1  본론에 앞서
---------------------------------------------------------------------

    저번 달에는 입가심으로 기억부류의 정복에 대하여 논했다. 혹시 입가
심할 때부터 울컥하고 체하지나 않았는지 모르겠다. 아뭏든 입가심을 아무
탈 없이 마친 사람에 한해 이번 달에는 C의 대명사인 포인터의  활용법을,
일단은 문자열을 다루는 데에만 국한시켜서 알아본 뒤에, 곧이어 본격적으
로 포인터 연산을 설명할 작정이다. 예측컨데 열심히 노력하면 대략  사흘
안에 이 글을 정복할 수 있다. 그리고 노파심에서 하는  말인데  배움에는
왕도고 나발이고 일체 없다는 점을 명심하기 바란다.


---------------------------------------------------------------------
  2  C의 문자열 포인터
---------------------------------------------------------------------

    문자열을 다루는 포인터를 특별히 문자열 포인터(string pointer)라고
한다. 문자열 포인터를 다루기 위해서 <예제 1>을 입력한  다음  실행시켜
보기 바란다. 새삼스럽겠지만 그 방법은 이렇다. 우선 터보 C를  기동하고
터보 에디터에서 <예제 1>을 입력한 다음 <F2>키로 디스크에 저장한다. 이
때 행번호까지 입력하면 안 된다. 그 후 <F9>키를 눌러  컴파일◎링크하는
데, 끝나면 에러가 있는지 확인하고 에러가 없으면 실행시킨다. 터보 C 1.
5에서는 <Alt-R>키를, 터보 C 2.0에서는 <Ctrl-F9>키를 누르면 예제가  실
행될 것이다. 그 실행 결과가 제대로 나왔는지 비교해보기 바란다.

<예제 1> 각종 문자열 포인터 연산
---------------------------------------------------------------------
 1: #define STRINGLEN 21
 2:
 3: void main(void)
 4: {
 5:     unsigned char chararray[STRINGLEN + 1];
 6:     unsigned char *ps;
 7:
 8:     clrscr(); <--- 화면 전체를 지우는 함수
 9:
10:     strcpy(chararray, "Welcome to my world !");
11:     ps = chararray;
12:
13:     printf("%s\n", chararray);
14:     printf("%s\n", ps);
15:
16:     printf("String length of ps:        %d\n", strlen(ps));
17:     printf("String length of chararray: %d\n", strlen(chararray));
18:     printf("ps[0]: '%c'\n", ps[0]);
19:     printf("ps[12] '%c', chararray[12] '%c'\n", ps[12], chararray[12
);
20:     printf("End of ps: %d\n", ps[strlen(ps)]);
21: }
---------------------------------------------------------------------
<예제 1>의 실행 결과

Welcome to my world !
Welcome to my world !
String length of ps:        21
String length of chararray: 21
ps[0]: 'W'
ps[12] 'y', chararray[12] 'y'
End of ps: 0
---------------------------------------------------------------------

  2.1 포인터 변수의 정의

    자, 그럼 이제부터 <예제 1>을 조목조목 분석해 보기로 한다.

 5:     unsigned char chararray[STRINGLEN + 1];
 6:     unsigned char *ps;

    5~6행은 문자 배열 chararray와 문자열 포인터 ps를 정의한다. 일반적
으로 단순 문자열 포인터의 정의는 아래와 같이 한다.

---------------------------------------------------------------------
 char *포인터명, *포인터명, ......;
    +---+
  또는  +---- 포인터가 가리키는 대상체(object)의 데이터형
    +---+
 unsigned char *포인터명, *포인터명, ......;
---------------------------------------------------------------------

    이와 같이 단순 문자열 포인터의 정의는 역시나 단순하다. 즉  포인터
명(포인터 변수명) 바로 앞에 구두점(punctuator) *만 갖다 붙이는 게  전
부이다.

  2.2 포인터의 의미

    그럼 여기서 포인터의 말 뜻을 알아보자.

<그림 1> 포인터는 곧 번지다.
+-------------------------------+
|                               |
|        포인터 == 번지         |
|                               |
|   the Pointer    the Address  |
|                               |
+-------------------------------+

---------------------------------------------------------------------
 * 한 마디로 포인터는 번지(address, 주소)에 대한  기호화된  표현이다.
   즉 포인터는 곧 번지라 할 수 있다.
 * 포인터 변수라는 것은 한 마디로 포인터, 즉 번지값을 저장하는 변수이
   다. 그런데 특별한 언급없이 그냥 포인터라고만 하면 포인터 변수,  포
   인터 상수나 기타 모든 번지값 등을 일컫는 것임에 유의한다.
---------------------------------------------------------------------

    그럼 번지란 무엇인가? 한 마디로 번지는 메모리상의 특정 위치를  숫
자(주로 16진수)로 표현한 것이다.
    그건 그렇고 <예제 1>의 설명을 계속 진행하기에 앞서 잠시  딴  얘기
좀 하겠다. 예컨데 문자열 포인터 변수 ptr을 아래와 같이 정의하면  변수
ptr이 일반적인 수치가 아닌 번지값(포인터)만을 전적으로 다루는  변수임
을 블럭 내에 선언하는 것이 된다.

    char *ptr;

    이 때 "포인터는 번지값을 나타낼 뿐인데 어째서 포인터 ptr을 정의할
때 ptr이 가리키는 대상체(object)의 데이터형인 char를 지정해 주어야 하
는가"라는 의문점은 이 글 뒷부분에서 설명하기로 하고 여기서는 그저  그
려려니하기 바란다.

  2.3 대입식의 의미

    우리가 주목할 점은 과연 아래의 대입식,

    ptr = "I'm a Rambo III";

가 의미하는 바가 무엇이냐 하는 것이다. 파스칼의 입장에서 따지면  아마
문자열 ptr에 문자열 상수 "I'm a Rambo III"를 대입(복사)하는  것쯤으로
해석할 수 있을 것이다. 그러나 C에서는 분명히 아니다.  왜냐하면  ptr은
문자열 변수도 아니고, 또 C에는 문자열 연산자가 전무후무하기 때문이다.
그러므로 =는 분명히 파스칼에서처럼 문자열을  복사(대입)하는  연산자가
결단코 아니다. 그럼 = 연산자가 C에서는 도대체 어떠한 일을 할까?
    ptr = "I'm a Rambo III"는 "I'm a Rambo III"라는 문자열이 저장되어
있는 메모리상의 선두번지를 포인터 ptr에 대입하라는 수식이다. 이  수식
이 실행되면 문자열 포인터 변수 ptr은 그 문자열 상수의  선두  번지값을
가지게 된다. 쉽게 말해서 문자열의 첫문자인 'I'가 저장되어 있는 번지값
이 ptr에 대입된다는 뜻이다. 대입 연산자만 가지고는 파스칼 경우처럼 문
자열 통채로 복사(대입)되는 일이 절대 발생하지 않는다(strcpy 함수를 써
야 한다).

<그림 2> 대입식의 의미(대입도 일종이 수식임)
---------------------------------------------------------------------

                                                  +-----널 종료문자
       ptr         =        "I'm a Rambo III"     |
                                                  |
                                                  |
   +--------+  선두번지값  +---+----------------+-+--+
   |        |<-------------+ I | 'm a Rambo III | \0 |
   +--------+    대입      +---+----------------+----+

   문자열 상수 "..."가 수식에 사용되었을 때 "..." 자체는
   그 문자열이 저장되어 있는 메모리상 위치의 선두번지값을 가진다.

---------------------------------------------------------------------

<그림 3> 대입식의 결과(실제 상황)
---------------------------------------------------------------------

                                                   +-----널 종료문자
   포인터 ptr                   "I'm a Rambo III"  |
   +--------+              +---+----------------+--+-+
   | 번지값 |              | I | 'm a Rambo III | \0 |
   +--------+              +---+----------------+----+

---------------------------------------------------------------------

    좀전의 대입식의 결과로 인해,

    "이제 포인터 변수 ptr은 문자열의 선두문자 'I'가 저장되어 있는  위
    치의 번지값을 가지게 되었다."

라고 말할 수 있다. 그런데 읽다보니까 말이 너무 길다고  생각되지  않는
가? 이 말을 C의 세계에서는 유식하고 멋지게 다음과 같이 말한다.

    "이제 포인터 ptr은 문자열의 선두번지를 가리키게(point) 되었다."

    말이 참으로 간결하지 않은가? 이 말을 보기 좋게 그림으로  표현하면
<그림 4>와 같다. 이제부터 이 글에서는 지면을 절약하기 위해 가급적  긴
말 대신 짧고 간결한 말을 자주 사용할테니 용어에 착오없기 바란다.

<그림 4> "포인터 ptr은 문자열의 선두번지를 가리킨다."의 개념도
---------------------------------------------------------------------

                             +---선두번지
   포인터 ptr                |
   +--------+  선두번지를  +-+-+----------------+----+
   |   o ---+------------> | I | 'm a Rambo III | \0 |
   +--------+  가리킨다    +---+----------------+----+
                 |
                 |
                 +----- 이 "가리킨다"라는 말은 개념적인 것이다.
                        실제 뭔가가 연결되어 있다는 뜻은 절대 아니다.
                        실제 상황은 <그림 3>일 따름이고 이 그림은
                        실제 상황을 포인터 개념을 써서 보기 좋게
                        그린 것 뿐이다.

---------------------------------------------------------------------

    자, 이제다시 본론으로 돌아가자. 참 아까 빠뜨렸는데 5행의 문자 배
열 chararray 정의에서 배열크기가 STRINGLEN + 1인 이유는, 문자열의  끝
임을 표시하는 널 종료문자(null terminator) '\0'을 저장하기 위해, 저장
할 문자열의 전체 길이에 추가로 1바이트가 더 필요하기 때문이다.  8행은
화면 전체를 지운다.

<그림 5>  포인터와 문자 배열의 메모리 구조
---------------------------------------------------------------------

            포인터 ps
            +--------+
            |        |
            +--------+

                  +--------- 현재 텅텅 비어있다.
                  |          (실제로는 쓰레기값이 들어 있다)
                  |
                               문자 배열 chararray
   총   +---+---+---+---+---+---+-------+---+---+---+---+---+---+---+
22바이트|   |   |   |   |   |   | o o o |   |   |   |   |   |   |   |
        +---+---+---+---+---+---+-------+---+---+---+---+---+---+---+
배열요소 [0] [1] [2] [3] [4]             [15][16][17][18][19][20][21]
          |                                                        |
          +----------------- 배열크기  22바이트 -------------------+

---------------------------------------------------------------------

    이상에서 문자 배열 chararray와 문자열 포인터 변수 ps를  정의했다.
이렇게 하면 C는 그들을 위해 메모리상의 특별히 정해진 위치에 저장 장소
를 마련한다. 마련된 메모리의 구조는 <그림 5>에 나타냈다.

  2.4 포인터와 배열상수

10:     strcpy(chararray, "Welcome to my world !");

    위의 10행을 이해하려면 아래의 세 가지 의문점을 모두  해소해야  한
다.

---------------------------------------------------------------------
첫째, strcpy라는 함수가 하는 일이 무엇인가?
둘째, 배열명 chararray 자체가 의미하는 바는 무엇인가?
세째, 문자열 상수가 함수의 매개변수(parameter)로 지정되었을 때 무엇이
      함수로 넘어가는가?
---------------------------------------------------------------------

    청개구리 같지만 의문점을 세번째부터 꺼꾸로 풀어보자. 문자열  상수
는 어딘지는 몰라도 언제나 메모리의 한 귀퉁이를 차지한다(저장된다). 문
자열 상수가 함수의 매개변수로 지정되면 이렇게 메모리의 한 귀퉁이를 차
지한 문자열 상수의 선두번지가 함수로 넘어간다. 말을 바꾸면 문자열  상
수의 선두번지를 가리키는 포인터가 함수로 전달된다는 뜻이다. 즉 문자열
자체는 있던 그 자리에 얌전하게 두고 함수에게는 문자열이 저장되어 있는
그 자리의 선두번지만 전달하는 것이다.
    계속해서 두번째 의문점을 풀어보자. 그 의문점은  간단하게  풀린다.
즉 C에서 "배열명 chararray은 문자 배열 chararray의 선두번지를  가리키
는 번지값이다"라고 여기자고 약속이 되어 있다. 그 번지값을 이름하여 배
열 상수라고 일컫는다. 말을 바꾸면 배열명 chararray 자체는 그 문자  배
열의 선두번지를 가리키는 일종의 포인터 상수라는 뜻이다.
    이렇듯 배열명 chararray 자체는 어디까지나 수치 상수 10, 20.23  등
과 같은 계열의 "상수"이므로, 변수처럼 특별히 정해진  메모리상  위치에
배열 상수 chararray가 저장되어 있는 것이 아님을 주의하기 바란다. 따라
서 그림으로 표현하면 포인터 변수 ps와는 차이가 난다. charray가 메모리
의 어떤 곳에 저장되어 있는 것이 아님을 주목한다.



<그림 6> "배열명은 그 배열의 선두번지를 가리키는 포인터 상수이다"
---------------------------------------------------------------------

       chararray ------+
                      +-+-+-+-+-+-+-+-  --+-+-+-+-+-+
                      +-+-+-+-+-+-+-+--  -+-+-+-+-+-+
                            chararray 문자 배열

---------------------------------------------------------------------

    이제 10행의 윤곽이 대체적으로 잡혔다. 즉 10행은 strcpy라는 함수에
문자 배열 chararray의 선두번지와 문자열 상수 "Welcome to my world  !"
의 선두번지를 전달하는 것이다. 그럼 strcpy가 무얼 하는 함수인지만  알
면 끝난다.

  2.5 strcpy 함수의 동작

    함수명 strcpy는 "string copy"의 약자이다. 함수명으로 풀이하면 str
cpy는 문자열을 복사하는 함수임이 틀림없다. 이렇듯 파스칼의 대입  연산
자 :=가 행하는 문자열 대입(복사)을 C에서는 strcpy라는 함수가 대행하는
것이다. strcpy 함수가 실행되는 과정은 이렇다.
    먼저 strcpy는 두 개의 매개변수를 전달받는다. 그 매개변수는 둘  다
포인터(번지값)이다. 첫번째 번지를 destin이라하고 두번째 번지를 source
라 하자. strcpy가 하는 일은 바로 source 번지부터 널 종료문자까지의 모
든 문자들을 destin 번지에 차례차례 복사하는 것이다.
    그림으로 strcpy 함수의 동작을 알아보자.

<그림 7> strcpy 함수에 매개변수 전달 방법
---------------------------------------------------------------------

               선두번지만 전달
               +-------------+     문자 배열 chararray
+----------+   |            +-+-+-+-+-+-+-+-  --+-+-+-+-+-+
| strcpy   |   |            +-+-+-+-+-+-+-+--  -+-+-+-+-+-+
+----------+   |
| destin --+---+            +---+----------------------+----+
+----------+                | W | elcome to my world ! | \0 |
| source --+---+            +---+----------------------+----+
+----------+   |              |        문자열 상수
               +--------------+
               선두번지만 전달

---------------------------------------------------------------------

<그림 8> strcpy는 source 번지의 문자열을 destin 번지로 복사한다
---------------------------------------------------------------------

destin  --+
          |              문자배열 chararray
          |
        +-+-+---+---+---+---+-----------+---+---+---+---+---+---+---+
        | W | e | l | c | o |   o o o   | o | r | l | d |   | ! | \0|
        +---+---+---+---+---+-----------+---+---+---+---+---+---+---+
strcpy가  |   |   |   |   |               |   |   |   |   |   |   |
복사한다  |   |   |   |   |               |   |   |   |   |   |   |
        +-+-+-+-+-+-+-+-+-+-+-----------+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        | W | e | l | c | o |   o o o   | o | r | l | d |   | ! | \0|
        +-+-+---+---+---+---+-----------+---+---+---+---+---+---+---+
          |                                              |
          |                  문자열 상수                          |
source ---+                                                       |
여기서부터 복사를 시작한다             널 종료문자까지 복사한다 --+

---------------------------------------------------------------------

    10행을 분석해본 소감이 어떤가? 지금까지 설명은 차고 넘치도록 많이
했으므로 더 이상의 이야기는 잡담이 될 것 같아 그만두기로 한다. 그럼 1
1행으로 넘어가보자.

11:     ps = chararray;

    11행은 배열 상수 chararray를 포인터(문자열 포인터 변수) ps에 대입
한다. 배열 상수 chararray는 문자 배열 chararray의 선두번지값을 가지므
로 포인터 변수 ps에는 문자 배열 chararray의 번지값이  저장된다.  말을
바꾸면 11행의 대입식 이후 포인터 ps는 문자 배열 chararray의  선두번지
를 가리키게 된다는 뜻이다.
    여기까지의 상황을 그림으로 표시하면 다음과 같다. <그림 9>는  개념
도이고 <그림 10>은 실제 상황이다.


<그림 9> 개념도
---------------------------------------------------------------------

포인터 ps <--- 문자 배열 chararray의 선두번지를 가리킨다
+-------+
|   o --+-+
+-------+ |
          |               문자배열 chararray
        +-+-+---+---+---+---+-----------+---+---+---+---+---+---+---+
        | W | e | l | c | o |   o o o   | o | r | l | d |   | ! | \0|
        +---+---+---+---+---+-----------+---+---+---+---+---+---+---+
배열요소 [0] [1] [2] [3] [4]             [15][16][17][18][19][20][21]

---------------------------------------------------------------------

<그림 10> 실제 상황
---------------------------------------------------------------------

     포인터 ps <---- 문자 배열 chararray의 선두번지를 저장하고 있다.
     +--------+
     | 번지값 |
     +--------+
                             문자배열 chararray
        +---+---+---+---+---+-----------+---+---+---+---+---+---+---+
        | W | e | l | c | o |   o o o   | o | r | l | d |   | ! | \0|
        +---+---+---+---+---+-----------+---+---+---+---+---+---+---+
배열요소 [0] [1] [2] [3] [4]             [15][16][17][18][19][20][21]

---------------------------------------------------------------------

  2.6 문자열의 출력

    머리가 찌끈찌끈하더라도 쬐끔만 더 가면 쉴 수 있으니까 여기서 숨돌
릴 생각 말고 줄기차게 전진한다. 낙오하지 않고 전진하는 것만이  살길이
다. 계속해서,

13:     printf("%s\n", chararray);
14:     printf("%s\n", ps);

    13행은 문자 배열 chararray을 문자열로 간주하고 화면에 출력하는 것
이다.%s 서식은 인수(실매개변수)를 문자열 포인터로 인식하고 그 포인터
가 가리키는 번지부터 널 종료문자 사이에 있는 문자들을 출력하라는 의미
를 가진다. 배열명 chararray 자체는 그 배열의 선두번지를 가리키는 포인
터라고 누차 이야기했다. 따라서 13행은 문자 배열 chararray의 내용을 화
면에 출력하는 것이다.
    14행은 13행과 마찬가지이다. ps가 문자열 포인터 변수인데 포인터 ps
는 문자 배열 chararray의 선두번지를 가리키므로 14행은 결국 문자  배열
chararray를 화면에 출력하는 셈이 되어 14행은 13행과 똑같은 실행  결과
를 가져온다.

16:  printf("String length of ps:        %d\n", strlen(ps));
17:  printf("String length of chararray: %d\n", strlen(chararray));

    그 다음, 16행은 포인터가 ps가 가리키는 문자열의  길이를  출력하는
것이다. strlen 함수에 매개변수로서 포인터를 전달하면 strlen은 그 포인
터가 가리키는 번지부터 널 종료문자 직전까지의 문자의 갯수를 세어서 정
수값으로 리턴한다. 문자열의 길이를 되돌려 주는 파스칼의 Length 함수와
논리적으로 동등한 일을 한다.
    문자열 "Welcome to my world !"는 모두 22바이트의 메모리를  차지한
다. strlen 함수는 그 중에서 널 종료문자를 제외한 21을  리턴하는  것이
다.
    17행은 문자 배열 chararray를 문자열로 보고 역시 16행과 마찬가지로
22 - 1 == 21을 출력한다. 포인터의 입장에서 보면 문자열과 문자  배열을
전혀 구분할 수 없음을 상기하기 바란다. 즉 문자열과 문자 배열은 포인터
에 의해 동등하게 대우받는다. 문자 배열을 문자열로 간주하면 문자  배열
이 곧 문자열이 되는 것이다.


  2.7 포인터를 이용하여 문자열요소를 참조하는 방법


18: printf("ps[0]: '%c'\n", ps[0]);
19: printf("ps[12] '%c', chararray[12] '%c'\n", ps[12], chararray[12]);
20: printf("End of ps: %d\n", ps[strlen(ps)]);

    18행을 보자. 우선 chararray[0]이란 것이 무엇을 나타내는지 잘 알고
있으리라 믿는다. 그러면 일반적으로,

    ps[n]

이란 것은 무엇을 의미할까? 이 글 뒷부분에서 원칙적으로 설명하겠지만 p
s[n]은 문자열 포인터 ps가 가리키는 번지부터 n번째 문자열요소를 나타낸
다(첫요소가 제0번째). 문자 배열의 사용과 매우 흡사함을 알 수 있다. 실
제로 19행의 ps[12]와 는 chararray[12]는 서로 동일한 문자 'y'를 나타낸
다.
    어쨌든 ps[0]는 (포인터 ps가 가리키는 번지 + 0), 즉 문자열 "Welcom
e to my world !"의 선두번지에 있는 문자열요소를 나타낸다. 그 위치에는
보다시피 'W' 문자가 있다. 또한 chararray[0]에 다른 문자를  대입할  수
있듯이 ps[0]에도 다른 문자를 대입할 수 있다.
    마지막으로 20행은 무엇을 출력하라는 문장일까?  함수  strlen(ps)의
결과는 21이다. 그러므로 ps[strlen(ps)]는 ps[21]과 동일하다. 즉  (포인
터 ps가 가리키는 번지 + 21)의 번지에 저장되어 있는 문자열요소를  나타
낸다. 그 위치에 무엇이 있는가? <그림 11>을 보면 널 종료문자 '\0'가 저
장되어 있음을 알 수 있다. 결국 printf 함수에 의해 화면에는 0이 출력된
다.


<그림 11> 배열의 끝에 '\0'가 저장되어 있다.
---------------------------------------------------------------------

포인터 ps <--- 문자 배열 chararray의 선두번지를 가리킨다
+-------+
|   o   |
+---+---+ +--------------------- ps[0]
    |     |                   +- ps[12]
    |     |                   |  ps[strlen(ps)] ------------------+
    |     |                   |                                   |
    |   +-+-+-------+---+---+-+-+---+---+---+---+---+---+---+---+-+-+
    +---+ W | o o o |   | m | y |   | w | o | r | l | d |   | ! | \0|
        +---+-------+---+---+---+---+---+---+---+---+---+---+---+---+
배열요소 [0]         [10][11][12][13][14][15][16][17][18][19][20][21]
          |                   |
          |                   +- chararray[12]
          |
          +--------------------- chararray[0]

---------------------------------------------------------------------

    이것으로서 알고 보면 별 것도 아니지만 모르는 사람은 종잡을 수  없
는 <예제 1> 고지를 향하여 숨가쁘게 올라갔던 길고 긴 등정이 마침내  종
결되었다. 여기서 내용이 일단락되었으니 오늘은 이쯤에서 쉬고 다음 내용
은 내일부터 읽어들어가기 바란다. 괜히 욕심내서 더 읽어다간 배탈날테니
지금 책을 덮는게 정신 건강에 이로울 것이다.


---------------------------------------------------------------------
  3  일차원 배열 포인터와 포인터 연산
---------------------------------------------------------------------

    지금부터 이번 연재의 하일라이트인 포인터 연산에  대해  집중적으로
탐구해 보도록 하자. 사실 산술형 변수를 가리키는 포인터에만 관심이  있
다면 더 이상의 포인터 연산에 대해 주목할 필요가 없다.  그러나  배열을
다루는 포인터, 즉 배열 포인터라면 *나 & 연산자만으로는 태부족이다. 그
럼 그외에 어떠한 포인터 연산이 가능한지 하나하나 주의깊게 살펴보자.

  3.1 px + i의 의미

    int x[5], *px;
    px = x;

    위와 같이 px가 int형 포인터이고 px가 int형 배열의  첫  배열요소를
가리키고 있다고 할 때 px에 정수 수치 1을 더한 아래의 수식은 무엇을 의
미할까? (T형 포인터라 함은 대상체가 T형인 포인터를 뜻한다)

    +--------+
    | px + 1 |
    +--------+

    위의 수식은

    +---------------------------------------------------------+
    | px가 가리키는 배열요소 바로 다음의 배열요소를 가리킨다. |
    +---------------------------------------------------------+

    px 바로 다음 바이트의 번지를 가리키는 것이 아님에 주의해야  한다.
px + 1이 px 바로 다음 바이트의 번지를 가리키게 되는 경우는 px가  문자
포인터(character pointer), 즉 문자 배열 포인터나 문자열  포인터일  때
뿐이다.
    모든 int형 데이터는 2바이트 크기를 가진다. px가 int형 포인터,  정
확히는 정수 배열 포인터이므로 px + 1은 px + (2바이트)의 번지를 가리키
게 된다. px + 1이 px + (1바이트)의 번지를 가리키는 것이 아님을 확실하
게 기억해야 할 것이다.
    일반적으로 포인터에 정수 수치를 더한 수식의 의미는  아래와  같다.
이때 i는 정수 수치를 나타낸다.

    +-------------------------------------------------------------+
    | px + i가 가리키는 번지는 px + (i바이트)가 아니라            |
    |                          px + (i * sizeof(*px) 바이트)이다. |
    +-------------------------------------------------------------+

    px + i는 px가 무슨형 포인터인가에 전혀 상관없이 px가 가리키는  배
열요소 바로 다음의 배열요소를 가리킴을 주목해야 한다. 이 말을  바꿔서
말하면 px가 무슨형 포인터인가에 따라 px + i의 번지가 달라진다고 할 수
있다. 예를 들어 px가 double형 포인터이면 px + 1은 px + (8바이트)의 번
지를 가리키게 된다. <그림 12>를 참고하기 바란다.
    포인터 변수를 정의할 때에는 그 포인터 변수가 가리키는 대상의 데이
터형을 반드시 밝혀 주어야 하는 직접적인 이유가 바로 px +  i의  번지를
계산하기 위해 sizeof(*px)의 값이 필요하기 때문이다.

<그림 12> px + 1의 의미
---------------------------------------------------------------------

* px가 int형 포인터일 때

            px - 1   px      px + 1  px + 2  px + 3
             |       |       |       |       |
          -+-+-----+-+-----+-+-----+-+-----+-+-----+-
           |       |       |       |       |       |
          -+---+---+---+---+---+---+---+---+---+---+-
상대 번지    -2  -1  0   1   2   3   4   5   6   7


* pxx가 double형 포인터일 때

                    px              px + 1          px+ 2
                    |               |               |
           --------++--------------++--------------++--
                   |               |               |
           --+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
상대 번지   -4-3-2-10 1 2 3 4 5 6 7 8 910111213141516

---------------------------------------------------------------------

    여기까지 설명한 사항을 고려하면 아래와 같은 결론을 유도할  수  있
다.

---------------------------------------------------------------------
px가 배열의 첫 요소를 가리키고 있을 때 px + i는 배열의  i번째  요소를
가리킨다.
---------------------------------------------------------------------
px가 배열의 어떤 요소를 가리키고 있을 때 px - i는 그 요소의 i번째  앞
의 요소를 가리키게 된다.
---------------------------------------------------------------------
px가 배열의 어떤 요소를 가리키고 있을 때 px + i는 그 요소의 i번째  뒤
의 요소를 가리키게 된다.
---------------------------------------------------------------------

    이 말들은 포인터의 개념을 혼동없이 명확하게 이해하는 데 상당히 중
요한 어귀가 되므로 노랫가락 흥얼흥얼 외우듯이 몸에 배도록 반복해서 암
기해야 할 것이다.


  3.2 *(px + i)의 의미

    int x[5], *px;
    px = x;

    위와 같을 때 px는 정수 배열 x의 첫요소를 가리키고 있으므로 앞에서
언급한 바와 같이 px + i는 배열 x의 i번째 요소를 가리키게 된다. 따라서
*(px + i)는 배열 x의 i번째 요소의 내용을 나타낸다. 결론적으로

    +---------------------------------------------------+
    | x[i]와 *(px + i)는 완전히 동등(equivalent)한 수식 |
    +---------------------------------------------------+

이라 할 수 있다.
    다음 두 수식도 완전히 동등한(equivalent, not  identical!)  수식이
다.

------------------------------------------------------------------
  px = x;     <--- 배열상수 x는 첫번째 배열요소의 번지를 나타낸다.

  px = &x[0]; <--- &x[0]는 x[0]의 번지를 구한다.
------------------------------------------------------------------

<그림 13> *(px + i)와 x[i]는 동등(equivalent)한 수식이다.
---------------------------------------------------------------------

      배열상수 x
               |

배열요소     x[0]      x[1]      x[2]      x[3]      x[4]
       --+---------+---------+---------+---------+---------+---
배열 x   |         |         |         |         |         |
       --+---------+---------+---------+---------+---------+---
             *px    *(px + 1) *(px + 2) *(px + 3) *(px + 4)
             |         |         |         |         |
포인터 px    |         |         |         |         |
 +-------+   | px      | px + 1  | px + 2  | px + 3  | px + 4
 |   o --+---+---------+---------+---------+---------+
 +-------+

---------------------------------------------------------------------

  3.3 px[i]의 정체

    C에서 배열의 첨자를 나타내는 [ ]는 ( ) 등과 같은 종류의 기본 연산
자(primary operator)로 분류된다. [ ]가 연산자인 이유는 아래와 같이  [
]이 연산자로서 정의되어 있기 때문이다. 파스칼에서는 [ ]가 연산자가 아
닌 일종의 기호에 불과함을 상기하기 바란다.

    +--------------------------------------------------------+
    | px[i]는 *(px + i)와 완전히 동일한(identical) 수식이다. |
    +--------------------------------------------------------+

    문법적으로 표현하면 아래와 같다. 아무래도 글자 한 자 한 자에 신경
써서 달달 외우는 것이 좋을 성 싶다. 돌아앉으면 잊어먹을  테니까  하는
말이다.

---- 배열 참조(array reference)에 관한 정의 -------------------------

 E1[E2]는 정의에 의해 *((E1) + (E2))와 완전히 동일(identical)하다.

    보다 정확히 표현하면 (E1)[E2]와 *((E1) + (E2))임. 괄호는 연산순위
에 따라 생략 가능함.
    단, E1과 E2 중에서 둘 중에 하나는 반드시 포인터 수식이어야 하며
나머지 하나는 반드시 정수 수식이어야 한다. 둘 다 포인터 수식이거나 둘
다 정수 수식일 수는 없다.
---------------------------------------------------------------------

    부분배열(subarray)의개념에 대해서 아직 설명하지는 않았지만  예를
들어서 삼차원 배열의 경우,

---------------------------------------------------------------------
x[i][j][k] *(x[i][j] + k)  *(*(x[i] + j) + k)  *(*(*(x + i) + j) + k)
         (*(x + i))[j][k]  (*(*(x + i) + j))[k]
<----- 인간적인 표현 방식  컴퓨터적인 표현 방식 -------->
---------------------------------------------------------------------

    위의 수식 6개는 서로 완전히 동일하다. 비슷하거나(similar)  동등한
(equivalent, 똑같은 결과를 가지는) 것이 아니라 완전히 동일한(identica
l) 것이다.
    이렇게 보면 px[i]라는 것은 *(px + i)를 보다 간결하고 보다  인간적
으로 표현한 수식에 지나지 않음을 알 수 있다. 실제로 컴파일러는  px[i]
를 *(px + i) 형태의 기계어 코드로 컴파일한다. 마찬가지로 x[i]와 *(x +
i)도 완전히 동일(identical)한 수식이다.
    참고로 px[i]는 포인터 변수에 의한 배열 참조이고 x[i]는 포인터  상
수(배열 상수)에 의한 배열 참조이므로, px[i]와 x[i]가 완전히 동일한 수
식이라고 말할 수는 없다. 그러나 두 수식은 똑같은 배열요소를  참조하여
똑같은 결과값을 가지게 되므로 서로 동등(equivalent)한  수식이라고  한
다. "동일한 수식"과 "동등한 수식"이라는 용어에 혼동이 없기 바란다. 동
일한 수식은 똑같은 기계어 코드를 생성해내지만 동등한 수식은  결과값이
야 같지만 생성된 기계어 코드는 서로 다르다.
    그러면 완전히 동일한 두 수식 *(px + i)와 px[i] 중에서  어느  것을
쓰는 것이 좋은가에 의문을 가질 수 있다. 이 선택은 전적으로 프로그래머
의 기호에 달려 있다. 다만 포인터, 즉 번지라는 관점이 중요시된다면 *(p
x + i)를 사용하고 배열이라는 관점이 중요시된다면 px[i]를 사용하면  될
것이다.
    그런데 아래의 두 수식은 연산순위로 인해 서로 완전히 틀리다.

    +----------------------------------+
    | *px + 1는 *(px + 1)과 같지 않다. |
    +----------------------------------+

    *px + 1은 *px(즉 x[0])에 1을 더한 값이 된다. 그럼 <예제 2>를 통해
지금까지 설명한 모든 내용을 실제 눈으로 확인해 보자.

<예제 2> 일차원 배열과 포인터와의 관계
---------------------------------------------------------------------
void main(void)                             int형 배열을 초기화한다.
{                                                 |
    static int x[5] = {100, 200, 300, 400, 500}; -+
    int i, *px;  +- int형 포인터 변수 px를 정의한다.
            +----+           번지값을 출력할 때는 %p 서식을 쓴다.
    px = x;                    |
    printf("px = x;      px = %p\n", px);
    px = &x[0];
    printf("px = &x[0];  px = %p\n", px);

    printf("\n\ni    px + i  *(px + i)  px[i]  x[i]\n\n");
    for (i = 0; i <= 4; i++)
        printf("%d%9p%9d%9d%6d\n\n", i, px + i, *(px + i), px[i], x[i]);
}                                                  +---------------+
                                        이 수식들은 같은 값을 가진다.
---------------------------------------------------------------------
실행 결과(터보 C 2.0에서 실행)

px = x;      px = 0194 -+- px = x는 px = &x[0]와 같은 결과를가져옴을
px = &x[0];  px = 0194 -+  알 수 있다. 번지값 0194는 상황에 따라
                   달라질 수 있으니 번지값 자체에 괘념치 말기 바란다.
                  +-------+------+------+
i    px + i  *(px + i)  px[i]  x[i]     |
                                   서로 같은(equivalent) 값을 가진다.
0     0194-+    100      100   100
           +-+
1     0196-+ |  200      200   200
             |
2     0198   |  300      300   300
             |
3     019A   |  400      400   400
             |
4     019C   |  500      500   500
             |
  번지값이 sizeof(*px) == sizeof(int) == 2씩 증가함을 알 수 있다.
---------------------------------------------------------------------

    이상에서 배열과 포인터의 연산에 있어서 [ ]와 * & + 연산자가  가지
는 의미에 대하여 알아보았다. 알아보기는 했지만 이해가 가는지의 여부가
관건이다. 다행히 이해가 간다 하더라도 일체 혼동이 있어서는 안 되겠다.
쉽게 말해서 절대로 헷갈리지 않아야 한다. 조금이라도 헷갈렸다가는 죽도
밥도 안 된다.
    특히 중요한 것은 "과연 뭐가 같고", "과연 뭐가 틀린지", 그리고 "같
다면 과연 완전히 동일한 것인지, 아니면 그저 동등한  것인지"를  바위돌
칼로 두동강이 내듯 딱뿌러지게 구분하는 일이다. 칼로 물 베듯이  했다가
는 더 큰 혼란으로 부채질하는 결과 밖에 안 된다. 그러므로 지금 이 순간
전혀 헷갈리지 않는다는 확신이 서지 않는 한 머리도 식힐 겸  하루  정도
책을 놓고 푹 쉬었다가 내일 이 맘때쯤 해서 다시 읽어나가는 것이 현명한
상책이라고 본다. 어제도 말했지만 괜히 무리하게 욕심내서 한꺼번에 많은
것을 알려고 하는 것은 정신 건강에 이롭지 못하다.

  3.4 *px++, (*px)++, *++px, ++*px의 차이

---------------------------------------------------------------------
[1] *px++는 연산순위에 따라 *(px++)와 같다. 즉 *px값을 구하고 px를  1
    만큼 증가시키는 것이다. *px++는 *px와 px++의 두  수식을  연속하여
    연산한 결과와 같다.

[2] (*px)++는 일단 *px값을 구한 다음에 *px값을 1만큼 증가시킨다. px는
    증가하지 않는다.

[3] *++px는 연산순위에 따라 *(++px)와 같다. 즉 px를 1만큼 증가시킨 다
    음에 *px를 구한다. *++px는 ++px와 *px의 두 수식을 연속하여 연산한
    결과와 같다.

[4] ++*px는 ++(*px)와 같으며 *px의 값을 1만큼 증가시키고 그 값을 결과
    로 취한다. px는 증가하지 않는다.

[5] 각 수식이 단독으로 쓰일 경우, 즉 다른 수식 내에 포함되지 않고  쓰
    일 경우 [1]과 [3], [2]와 [4]는 각각 동등하다. 단독으로 쓰인 a++와
    ++a가 서로 동등함과 마찬가지이다. 이 경우 관습적으로 [3]번 대신 [
    1]번을 주로 쓴다. [2]와 [4] 중에서는 마음에 드는 것으로  골라쓰면
    된다.
---------------------------------------------------------------------

    포인터를 십분 활용하려면 이상에서 설명한 4개의 수식을  자유자재로
다룰 줄 알아야 한다. <예제 3>에 각 수식의 실제 상황을 예로 들었다. 구
차하게 설명을 하지는 않을테니 독자 스스로 분석하여 결론을 내리기 바란
다. (printf 함수의 서식문자열에서 %p 서식은 번지값을 출력하기 위한 것
이다. 매크로 함수 printexpr에 쓰인 #expr은 그러려니 하기 바란다.)
    덧붙여서 4개의 수식 중에서 사용빈도가 가장 높은 것은 *px++임을 참
고해 두면 좋겠다.

<예제 3> *px++,(*px)++, *++px, ++(*px)의 비교 분석
---------------------------------------------------------------------
#define initpx(i) printf("px == %p\n", px = x + i);
#define printexpr(expr) printf("Operation: " #expr " == %d\n", expr)
#define printpx() printf("After operation... px == %p\n", px)
#define printpx2() printf("                   *px == %d\n\n", *px)

void main(void)
{
    static int x[5] = {100, 200, 300, 400, 500};
    int *px;

    initpx(0);
    printexpr(*px++);
    printpx();
    printpx2();

    initpx(0);
    printexpr((*px)++);
    printpx();
    printpx2();

    initpx(3);
    printexpr(*px++);
    printpx();
    printpx2();

    initpx(3);
    printexpr(++(*px));
    printpx();
    printpx2();
}
---------------------------------------------------------------------
실행 결과(번지값은 상황에 따라 달라진다. 따라서 번지의 상대적인
값에만 주목하기 바란다.)

px == 0194
Operation: *px++ == 100
After operation... px == 0196
        *px == 200

px == 0194
Operation: (*px)++ == 100
After operation... px == 0194
                   *px == 101

px == 019A
Operation: *px++ == 400
After operation... px == 019C
                   *px == 500

px == 019A
Operation: ++(*px) == 401
After operation... px == 019A
                   *px == 401
---------------------------------------------------------------------


---------------------------------------------------------------------
  4  매개변수가 일차원 배열인 함수
---------------------------------------------------------------------

    지금까지 포인터의 개념과 그 연산 방법을 고생고생해서 익힌  이유를
찬찬히 따지고 보면 매개변수가 배열인 함수를 만들기 위함이라고  보아도
과언이 아니다.
    매개변수가 배열인 함수가 언젠가 한 번은 꼭 필요하기 마련이다.  그
런데 매개변수와 리턴값으로 배열 전체를 통채로 주고 받고 할 수는  없는
까닭에 그 함수는배열을 포인터로 간접 조작할 수 밖에 없다.
    외부배열을 쓰지 않는 한 다른 곳에 정의되어 있는  배열을  포인터를
쓰지 않고 원하는 특정 함수 내에서 조작할 수 있는 방도는 사실상 전무하
다. 게다가 외부배열을 쓰는 것은 프로그램 개발 과정에서 벌레의  위험성
으로 인한 무시하지 못할 부작용이 따르기 때문에 매개변수가 배열인 함수
를 언젠가는 만들어 쓸 수 밖에 없다. 그러자면 싫어도 어쩔 수 없이 포인
터를 써야한다.

  4.1 매개변수가 일차원 배열인 함수를 만드는 방법

    매개변수가 일차원 배열인 함수는 포인터를 써서 간단하게 만들 수 있
다. <예제 4>의 sum과 sum2라는 함수가 실례이다. sum과 sum2가 하는 일은
double형 포인터 px가 가리키는 배열요소로부터 n개의 요소를 합산하는 것
이다.
    sum2는 배열을 합산하는 방법이 약간 다를 뿐이고 결과는 sum과  똑같
다. sum은 포인터의 관점에서 배열을 합산했고 sum2는 배열의 관점에서 배
열을 합산했다. 똑같은 px의 선언이라도 보는 관점에 따라 두 가지 방법이
있을 수 있다. 하나는 double *px이고 나머지 하나는 double px[]이다.

<예제 4>  매개변수가 배열인 함수
---------------------------------------------------------------------
#define printexpr(expr) printf(#expr " == %.1f\n", expr)

double sum(double x[], unsigned n);
double sum2(double x[], unsigned n);

void main(void)
{
    double x[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};

    printexpr(sum(x, sizeof(x) / sizeof(double)));---배열 전체를 합산
    printexpr(sum2(x, sizeof(x) / sizeof(double)));

    printexpr(sum(x, 5)); --- 배열요소 [0],...,[4]를 합산한다.

    printexpr(sum(x + 5, 5)); --+- 배열요소 [5],...,[9]를 합산한다.
    printexpr(sum(&x[5], 5)); --+
}
                  +-----------------+
                  |                 |
double sum(double *px, unsigned n)  |
{                           +-------+----- 포인터의 관점에서 합산
    double sum = 0.;        |       |
                            |       +-두 선언은 서로 완전히 동일함
    while (n-- > 0) sum += *px++;   |
    return sum;                     |
}                   +---------------+
                    |
double sum2(double px[], unsigned n)
{
    int i;                           +-------배열의 관점에서 합산
    double sum = 0.;                 |
                                     |
    for (i = 0; i < n; i++) sum += px[i];
    return sum;
}
---------------------------------------------------------------------
실행 결과

sum(x, sizeof(x) / sizeof(double)) == 55.0
sum2(x, sizeof(x) / sizeof(double)) == 55.0
sum(x, 5) == 15.0
sum(x + 5, 5) == 40.0
sum(&x[5], 5) == 40.0
---------------------------------------------------------------------


  4.2 배열의 끝을 감지하는 방법

    포인터는 원래부터 배열의 크기를 알지 못한다. 마찬가지로  포인터는
배열의 시작과 끝을 감지하지 못한다. 여기서 매개변수가  배열인  함수가
범용성을 가질 수 있도록 해주는 대단히 편리한 융통성이 드러난다.

---------------------------------------------------------------------
C에서는 크기가 가변인 배열을 다루는 함수를 매우 손쉽게 만들 수 있다.
---------------------------------------------------------------------

    파스칼에서는 배열크기를 반드시 명시해야 함과 비교해보면 C의  함수
는 엄청난 융통성을 발휘할 수 있다는 사실을 알 수 있다. 이 점이 바로 C
의 융통성을 대변하는 가장 큰 특징이다.
    어쨌든 포인터만으로는 배열의 시작과 끝을 알아내는  것이  불가능하
다. 그런데 배열의 시작은 어차피 함수의 매개변수를 통해 전달되므로  필
요한 것은 배열의 끝을 감지하는 방법이다. 방법은 대략 두  가지가  있을
수 있다.

---------------------------------------------------------------------
첫째, 함수의 매개변수로 배열의 시작을 가리키는 포인터와 함께 배열크기
      를 동시에 전달하는 것이다. <예제 4>의 sum 함수가 이에 해당한다.
      이것은 크기가 가변인 배열을 다루는 가장 일반적인 방법이다.
둘째, 프로그래머가 특별히 약속된 표지를 배열에 해두는 것이다.  예컨데
      문자열의 널 종료문자 '\0'같은 것이 그러한 표지의 대표적인  실례
      에 해당한다. 즉 처리하고자 하는 배열의 최후 요소에 0과 같은  특
      별한 값을 둠으로써 함수로 하여금 배열의 끝을 감지할  수  있도록
      하는 방법이다.
---------------------------------------------------------------------

    두 가지 방법을 비교해 볼 때 두번째 방법은 문자열 또는 문자 배열을
다룰 때 주로 쓰이고 첫번째 방법은 그 이외의 일반적인 배열을  다룰  때
흔히 쓰인다.

  4.3 double x[]와 double *x

    다음으로 <예제 4>에서 알 수 있듯이 함수의  매개변수  리스트에서는
아래의 두 선언이 완전히 동일하다. double[]라는 선언이  가능한  이유는
그것이 형식매개변수(formal parameter)의 "선언(declaration)"이기  때문
이다.

    +------------+
    | double x[] |
    | double *x  |
    +------------+

    둘 다 double형 배열을 가리키는 포인터 변수로서  형식매개변수  x를
선언한 것이다. 주목할 것은 double x[]라고 x를 선언했지만 x는  상수(배
열 상수)가 아니라 변수(형식매개변수)라는 점이다. 더욱 주의할 사항은 d
ouble x[]라는 선언이 외부변수의 선언 방법과 비교해볼 때 그 형태는  유
사하더라도 그 의미는 전혀 다르다는 것이다. 예를 들어서 아래와 같은 외
부변수 선언과 형식매개변수의 선언이 있을 경우,

extern double x[];

double function(double px[], ......)
{
 ......
}

extern double x[]는 x라는 외부배열을 알리는 선언이므로 배열명 x는 "배
열 상수(포인터 상수)"로서 알려진다. 따라서 x++와 같은 수식을  쓰면  C
컴파일러가 몹시 심한 거부 반응을 일으킨다. 그러나 double px[]는  형식
매개변수로서 배열을 가리키는 포인터 px를 선언한 것이므로 px는 "포인터
변수"가 된다. 따라서 px++와 같은 수식은 아무런 저항없이 계산된다.  마
찬가지로 아래의 두 선언 역시 전혀 다른 의미를 가진다.

extern double x[]; <--- 일차원 배열을 선언
extern double *px; <--- 포인터 변수를 선언

    이처럼 유사한 형태의 선언일지라도 그 선언이 위치한 곳에 따라 전혀
다른 의미를 가지므로 마땅히 주의해야 할 것이다. 만약 double x[]와 dou
ble px[]의 차이점이 명확히 구분되지 않는다면 안전을 기하기 위해  아예
int *px라는 형식매개변수 선언 방식만을 고집하여 쓰는 것이 속 편할  것
으로 본다.

  4.4 정렬 함수 bubble의 작성

    매개변수가 배열인 함수의 전형적인 예로서 정렬 함수를 빼놓을  수가
없다. 여기서는 수 많은 정렬 알고리즘 중에서 가장 간단하다고 정평이 나
있는 n2 계열의 거품 정렬(bubble sort)을 쓰기로 한다.

<예제 5> 거품 정렬(bubble sort)
---------------------------------------------------------------------
#include <stdlib.h> <--- 매크로 함수 randomize와 random이
                         정의되어 있다.
#define MAX 20

void bubble(int x[], unsigned n); <--- 함수 선언

void main(void)
{
    int x[MAX];
    int i;       +---난수 발생기를 초기화한다.
                 |                      +---난수를 발생시킨다.
    randomize(); |                      |
    for (i = 0; i < MAX; i++) x[i] = random(100);

    printf("\nGenerated array:");
    for (i = 0; i < MAX; i++) printf("%3d", x[i]);

    bubble(x, MAX);

    printf("\nSorted array:   ");
    for (i = 0; i < MAX; i++) printf("%3d", x[i]);
}

void bubble(int x[], unsigned n)
{
    regipser i, j;
    int temp;

    for (i = 0; i < n - 1; i++)
        for (j = n - 1; j > i; j--) {
            if (x[j - 1] <= x[j]) continue;
            temp = x[j - 1]; ---+
            x[j - 1] = x[j];    +- x[j - 1]과 x[j]를 교환한다.
            x[j] = temp;     ---+
        }
}
---------------------------------------------------------------------
실행 예

Generated array: 52 66 4  80 41 47 95 62 68 30 64 29 85 60 97 75 69 
 72  3 13
Sorted array:    4  13 29 30 33 41 47 52 60 62 64 66 68 69 72 75 80 
 85  9 97
---------------------------------------------------------------------


---------------------------------------------------------------------
  5  다음에는
---------------------------------------------------------------------

    지금까지 사흘에(내지는 한 달에) 걸쳐 포인터 연산에 관해  전반적으
로 익혔다. 독자 여러분이 제대로 익혔는지 구웠는지  삶아먹었는지는  알
수 없으나, 아뭏든 필자는 게의치 않고 다음 연재를 이어나갈 것이다.  낙
오자는 상처만이 남을 것이니 매진하시라!
다음에는 표준적인 C 언어 전체를 통털어서 함수 포인터 다음으로 가장 난
해하다고 공식 인정되고 있는 "다차원 배열을 포인터로 다루는 방법"에 대
하여 집중적으로 탐구하고자 한다. 관심있는 사람은 한 달만  기다리시라.
모든 의문점이 쑤-악 씻겨 내려 갈테니 말이다.

---------------------------------------------------------------------
  부록  덤으로
---------------------------------------------------------------------

    지난 달과 마찬가지로 이번에도 덤으로 그래픽 예제 하나  돌려보기로
한다. 내용에는 신경쓰지 말고 그저 실행시켜보는 재미에  만족하기  바란
다.
    우선 예제를 globe.c라는 화일명으로 입력부터 한다. 다 입력하고  디
스크에 세이브했으면, <Alt-F><O>키를 눌러 도스로 빠져나가서 현재  디렉
토리(current directory)에 herc.bgi라는 그래픽 구동기(graphics driver)
화일이 있는지 점검한다. 이 화일이 없으면 예제가 실행되지 않는다.  EGA
사용자라면 그것 대신에 egavga.bgi라는 그래픽 구동기 화일이  필요하다.
점검했으면 도스 명령행에 exit⇔를 입력하여 터보 C 통합 개발 환경(약칭
IDE)으로 되돌아온다.
    그런 다음, 만약 독자의 터보 C가 버전2.0이라면, <F9>키를 눌러 컴파
일 ◎링크가 무사히 끝나는가 확인하고 <Ctrl-F9>키를 눌러서 예제를 실행
시킨다.
    만약 터보 C 1.5라면 아래 두 줄의 짤막한 내용을 globe.prj라는 화일
명으로 입력한 뒤 <F2>키를 눌러 디스크에 세이브시킨다.

---------------------------------------------------------------------
globe
graphics.lib
---------------------------------------------------------------------

    이제 <Alt-P>를 눌러 "Project" 메뉴를 선택하고 곧이어 "Project nam
e" 항목을 택한다. 그러면 IDE가 프로젝트 화일명의 입력을 요구하는데 gl
obe⇔라고 입력하면 된다. 그런 다음 <F9>키를 눌러 컴파일, 링크가  무사
히 끝나는지 확인하고 <Alt-R>키를 눌러 예제를 실행시킨다.
    예제를 실행시키면 화면에 지구본이 하나 그려질 것이다. 자세히 보면
지구본 가운데에 점이 하나 찍혀 있을텐데, 거기가 어디냐  하면,  필자가
사는 집이다.


<덤 예제> 지구본 그리기
---------------------------------------------------------------------
/* File GLOBE.C: Terrestrial Globe - HGC/EGA version */

#include <graphics.h>
#include <math.h>

typedef enum {false, true} boolean;

void graph(double y, double z, int *plotted);
void rotate3d(double xr, double yr, double zr,
              double *px, double *py, double *pz);

#define LATITUTE 37.29     지구본 중앙점의 위도와 경도(변경 가능)
#define LONGITUTE 127.04   이 값 이외의 수치는 손대지 말 것
                                /*      |z        */
#define RADIUS 200.             /*      |         */
#define ZROTATE -LONGITUTE      /*    p/|   */
#define YROTATE -LATITUTE       /*     |+------ y */
#define XROTATE 22.5            /*     /-/        */
#define INTERVAL 15.            /*    /  fi       */
                                /*   x            */
void main(void)
{
    int graphdrive = DETECT, graphmode;
    int plotted;
    double x, y, z;
    double p, fi;
    double zr, yr, xr;

    initgraph(&graphdrive, &graphmode, "");

    xr = XROTATE * M_PI / 180.;
    yr = YROTATE * M_PI / 180.;
    zr = ZROTATE * M_PI / 180.;
    circle(getmaxx() / 2, getmaxy() / 2, RADIUS);
    circle(getmaxx() / 2, getmaxy() / 2, 1);

    /* Latitute */

    for (p = M_PI_2; p > -M_PI_2; p -= INTERVAL * M_PI / 180.) {
        plotted = false;
        if (fabs(p - 0.) < 1.e-5)
            setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
        else setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
        for (fi = 0.; fi <= 2. * M_PI; fi += M_PI / 24.) {
            x = RADIUS * cos(p) * cos(fi);
            y = RADIUS * cos(p) * sin(fi);
            z = RADIUS * sin(p);
            rotate3d(xr, yr, zr, &x, &y, &z);
            if (x < 0.) plotted = false;
            else graph(y, z, &plotted);
        }
    }

    /* Longitute */

    for (fi = 0.; fi < M_PI; fi += INTERVAL * M_PI / 180.) {
        plotted = false;
        if (fi == 0.) setlinestyle(SOLID_LINE, 0, THICK_WIDTH);
        else setlinestyle(SOLID_LINE, 0, NORM_WIDTH);
        for (p = 0.; p <= 2. * M_PI; p += M_PI / 24.) {
            x = RADIUS * cos(p) * cos(fi);
            y = RADIUS * cos(p) * sin(fi);
            z = RADIUS * sin(p);
            rotate3d(xr, yr, zr, &x, &y, &z);
            if (x < 0.) plotted = false;
            else graph(y, z, &plotted);
        }
    }

    getch();
    closegraph();
}

/* Rotation order :  z axis -> y axis -> x axis */

void rotate3d(double xr, double yr, double zr,
              double *px, double *py, double *pz)
{
    double x = *px, y = *py, z = *pz;
    double x1, y1, z1, x2, y2, z2, x3, y3, z3;

    x1 = x * cos(zr) - y * sin(zr);
    y1 = x * sin(zr) + y * cos(zr);
    z1 = z;

    x2 = x1 * cos(yr) - z1 * sin(yr);
    y2 = y1;
    z2 = x1 * sin(yr) + z1 * cos(yr);

    x3 = x2;
    y3 = y2 * cos(xr) - z2 * sin(xr);
    z3 = y2 * sin(xr) + z2 * cos(xr);

    *px = x3;
    *py = y3;
    *pz = z3;
}

void graph(double y, double z, int *plotted)
{
    int xx, yy, xasp, yasp;

    getaspectratio(&xasp, &yasp);
    xx = getmaxx() / 2 + (int)y;
    yy = getmaxy() / 2 - (int)(z * xasp / yasp);
    if (*plotted == false) moveto(xx, yy);
    else lineto(xx, yy);
    *plotted = true;
}
---------------------------------------------------------------------
